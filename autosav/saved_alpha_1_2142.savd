


 _newfile_ :Z:\DESKTOP\CODING\delta2d/./deltaworld.py




#newversion



import pyglet
import PIL as pil
import time,os,json,random
from pyglet.window import key

from src.TerrainCreator import *
from src.utils import *
import src.graphic as graphic
import src.terrain as terrain
import src.drawable as drawable
import src.tile_utils as tut
import src.positions as pup
import src.perso as pso
import src.getsave as gs


CURRENT_PATH = os.path.dirname(os.path.abspath(__file__)) # fopatouché
if ' ' in CURRENT_PATH:
    print('Le chemin d\'acces contient un espace. Le programme va BUGUER SA MERE.')
    print('Changez le programme de place pour un path sans espace svp.')

SAVES_PATH = '/saves/' # sous dossier principal où seront stockées les sauvegardes des mondes

SIZE_TERRAIN = 4,4 # en bioms  ## si c'est au dessus de 27*27 ya au moins 1 min de loading au début !! aoutch
SIZE_BIOM = 32,32 # en cases ## à modifier comme tu le souhaites
SIZE_TILE = 32 # en px ## à pas toucher sinon ça CRASH TOUT

tut.set_var(SIZE_TERRAIN,SIZE_BIOM,(SIZE_TILE,SIZE_TILE))

TAKE_DIRECT_SCREEN = False

NB_BOTS_CREATE = 20

class App(pyglet.window.Window):


    ### INIT FUNCTIONS

    def __init__(self):

        super(App, self).__init__()

        self.path = CURRENT_PATH

        icon1 = pyglet.image.load(self.path+'/item/logo16.png')
        icon2 = pyglet.image.load(self.path+'/item/logo32.png')
        self.set_icon(icon1, icon2)

        ### screens

        #self.screens = pyglet.window.get_platform().get_default_display().get_screens()
        display = pyglet.canvas.get_display()
        self.screens = display.get_screens()
        #print('screens',self.screens)
        used_screen = self.get_current_screen()

        self.size_scr = 1000,800
        self.size_fullscr = [used_screen.width,used_screen.height]

        self.fscreen = True
        self.set_size(self.size_scr[0],self.size_scr[1])
        self.set_fullscreen(self.fscreen,screen=used_screen)
        self.current_size_scr = self.size_fullscr
        #self.on_my_resize()

        # loading fonts
        font_path = 'item/fonts/'
        self.fonts = ['Modular Amplitude','starguard','starguard3d','starguardcond','starguardhalf']
        self.font = ['Star Guard','Star Guard 3D','Star Guard Halftone']
        for ft in self.fonts:
            try:
                pyglet.resource.add_font(font_path+ft+'.otf')
                #print(ft,'done')
            except:
                try:
                    pyglet.resource.add_font(font_path+ft+'.ttf')
                except :
                    pyglet.resource.add_font('arial.ttf')
                #print(ft,'ttf done')

        ### managers

        self.manager = graphic.MainManager(CURRENT_PATH)
        self.group_manager = graphic.GroupManager()
        self.graphic = graphic.GraphManager(self.manager,self.group_manager)
        self.labman = graphic.LabelManager(self.manager,self.group_manager,self.font[0])
        self.cmd = graphic.CmdManager((20 , self.size_fullscr[1] - 50))
        self.specMan = graphic.SpecialManager(self.manager,self.current_size_scr)

        self.aff_cmd = False


        #self.load()

    def init(self):

        self.in_land = False

        # CREATION TERRAIN partie 1
        self.color_list = [1,3,4,5,6,7,8,9,10,11,12,13,14,15]
        self.generated_terrains = 1


        ## DECLARATION ET SEPARATIONS DES IMAGES
        elapsed_time =time.time()

        self.textids = {}

        self.textids['ground'] = self.manager.loadImSeq('ground','back.png',512,512)
        self.textids['persos'] = self.manager.loadImSeq('perso','perso.png',512,512)
        self.textids['effects'] = self.manager.loadImSeq('effects','effects.png',512,512)
        self.textids['number'] = self.manager.loadImSeq('number','number.png',512,512)
        self.effectMan = graphic.EffectManager(self.graphic,self.textids['effects'])

        self.textids['title'] = self.manager.loadIm('title','titre.png')
        self.textids['target'] = self.manager.loadIm('target','target.png')
        #self.textids['blur'] = self.manager.loadIm('blur','flou.png')
        self.textids['inventory_hud'] = self.manager.loadIm('inventory_hud','inventory.png')
        self.textids['game_over'] = self.manager.loadIm('game_over','gameover.png')
        self.textids['hud'] = self.manager.loadImSeq('hud','hud.png',512,512)

        print('   -CHARGEMENT DES TEXTURES :',truncate((time.time() - elapsed_time),3))

        self.effects = []

        # DECLARATION DES TAB DE SPRITES

        self.sprids = {}
        self.sprids['target'] = self.graphic.addSpr(self.textids['target'],vis=False,static=True)
        self.graphic.addToGroup(self.sprids['target'],['up'])

        self.aff_target = False
        self.nb_spr_to_draw = [(self.current_size_scr[0]+32*2)//32,(self.current_size_scr[1]+32*2)//32]

        self.sprids['inventory_hud'] = self.graphic.addSpr(self.textids['inventory_hud'],pup.BOX['hud_inventory'][0].pos(),vis=False,static=True)
        #self.inventory_box = ( (31,190) , (550,791) )
        #self.graphic.createGroup('hud-1',11)
        self.graphic.addToGroup(self.sprids['inventory_hud'],['hud'],-1)

        self.selection = 'normal'

        # CREATION SPRITES PARTICULIER (affichage GAME OVER)

        size_game_over_spr = 834,192
        pos_game_over_spr = self.current_size_scr[0]/2-size_game_over_spr[0]/2,self.current_size_scr[1]/2-size_game_over_spr[1]/2
        self.sprids['game_over'] = self.graphic.addSpr(self.textids['game_over'],pos_game_over_spr,vis=False,static=True)
        self.graphic.addToGroup(self.sprids['game_over'],['up'],-1)

        # DECLARATION DES TAB DE LABELS

        self.lblids = {}
        self.lblids['hud'] = {}

        ## CREATION EFFETS
        elapsed_time =time.time()
        self.create_effects()
        print('   -CREATION DES EFFETS :',truncate((time.time() - elapsed_time),3))


        ## INIT

        # keys
        self.keys = key.KeyStateHandler()
        self.push_handlers(self.keys)

        # clicks
        self.clicks = {'L':False,'R':False,'M':[0,0]}
        self.mouse_speed = 0


        self.goodkeys = {key.SPACE : ' ',key.EXCLAMATION : '!',key.DOUBLEQUOTE : '\"',key.HASH : "#"
                        ,key.POUND : '£',key.DOLLAR : '$',key.PERCENT : '%',key.AMPERSAND : '*'
                        ,key.APOSTROPHE : '\'',key.PARENLEFT : '(',key.PARENRIGHT : ')',key.ASTERISK : '*'
                        ,key.PLUS : '+',key.COMMA : '*',key.MINUS : '*',key.PERIOD : '*',key.SLASH : '\\',key._0 : '0'
                        ,key._1 : '1',key._2 : '2',key._3 : '3',key._4 : '4',key._5 : '5',key._6 : '6',key._7 : '7',key._8 : '8',key._9 : '9'
                        ,key.COLON : '*',key.SEMICOLON : '*',key.LESS : '-',key.EQUAL : '=',key.GREATER : '*',key.QUESTION : '?',key.AT : '@'
                        ,key.BRACKETLEFT : '[',key.BACKSLASH : '/',key.BRACKETRIGHT : ']',key.ASCIICIRCUM : '*',key.UNDERSCORE : '_',key.GRAVE : '`'
                        ,key.QUOTELEFT : '<',key.A : 'a',key.B : 'b',key.C : 'c',key.D : 'd',key.E : 'e',key.F : 'f',key.G : 'g',key.H : 'h',key.I : 'i'
                        ,key.J : 'j',key.K : 'k',key.L : 'l',key.M : 'm',key.N : 'n',key.O : 'o',key.P : 'p',key.Q : 'q',key.R : 'r',key.S : 's'
                        ,key.T : 't',key.U : 'u',key.V : 'v',key.W : 'w',key.X : 'x',key.Y : 'y',key.Z : 'z',key.BRACELEFT : '{',key.BAR : '|'
                        ,key.BRACERIGHT : '}',key.ASCIITILDE : '*'
                        ,key.NUM_0 : '0',key.NUM_1 : '1',key.NUM_2 : '2',key.NUM_3 : '3',key.NUM_4 : '4',key.NUM_5 : '5',key.NUM_6 : '6'
                        ,key.NUM_7 : '7',key.NUM_8 : '8',key.NUM_9 : '9',

                        }

        # actions
        self.playing = True
        self.actions = ['menu','loading','showing','nothing','showing2','creating']
        self.action = 0
        self.security = 'admin'

        self.cmd.add(' ',self.actions[self.action])
        #print(self.actions[self.action])


        self.init_menu()

        self.nb = 0

        pyglet.clock.schedule_interval(self.gameloop,0.0000001)
        pyglet.app.run()

    def create_effects(self):

        # CREATION BIG BLUR FOR ALL SCREEN

        self.nb_spr_to_draw_x = self.current_size_scr[0]//tut.SIZE_TILE[0] + 1
        self.nb_spr_to_draw_y = self.current_size_scr[1]//tut.SIZE_TILE[0] + 1


        blur_spending1 = random.choice([i for i in range(5)])
        blur_spending2 = random.choice([i for i in range(blur_spending1+2,11)])

        #print(blur_spending1,blur_spending2)
        terrain = []
        for i in range(self.nb_spr_to_draw_y):
            taby = []
            for j in range(self.nb_spr_to_draw_x):
                taby.append(random.choice([i for i in range(blur_spending1,blur_spending2)]))
            terrain.append(taby)
        self.effects.append(self.effectMan.addEffect('blur%_allscr',terrain,(0,0),-10))

        terrain = []
        for i in range(self.nb_spr_to_draw_y):
            taby = []
            for j in range(self.nb_spr_to_draw_x):
                taby.append(random.choice([i for i in range(blur_spending1,blur_spending2)]))
            terrain.append(taby)
        self.effects.append(self.effectMan.addEffect('blur%2_allscr',terrain,(10,10),-9))

        terrain = []
        for i in range(self.nb_spr_to_draw_y):
            taby = []
            for j in range(self.nb_spr_to_draw_x):
                taby.append(random.choice([1,2,3]))
            terrain.append(taby)
        self.effects.append(self.effectMan.addEffect('blur25_allscr',terrain,(0,0),-8))

        # CREATION WHITE BLUR NEW MAP

        nbx = (3*self.current_size_scr[0]//4)//tut.SIZE_TILE[0]
        nby = (self.current_size_scr[1]//2)//tut.SIZE_TILE[0]
        posx = self.current_size_scr[0]/8
        posy = self.current_size_scr[1]/6

        effect_terrain = []

        #blur_color = random.choice([i for i in range(1,10)])
        for j in range(nby):
            taby = []
            for i in range(nbx):
                taby.append(10)
            effect_terrain.append(taby)

        self.effects.append(self.effectMan.addEffect('blur70_newland',effect_terrain,(posx,posy),-7))
        self.effectMan.unhide('blur70_newland',True)

    def init_menu(self):

        ## OKLM

        self.buttons = {}
        self.actions_menu = ['main','maps','newmap','pause']
        self.action_menu = 0


        ## CREATION SPRITES ET DIFFERENTS LABELS / BUTTONS / WRITINGS

        self.sprids['menu'] = {}
        self.sprids['menu']['all_maps'] = {}

        self.sprids['menu']['title'] = self.specMan.addSpr(self.textids["title"],self.current_size_scr[0]//2-1011//2,(self.current_size_scr[1]//4)*3,'title')
        #thg = #,color=(70, 110, 180,255))
        self.sprids['menu']['play_btn'] = self.specMan.addThg(drawable.LabelButton(self.choice_land,(300,100),'PLAY',
                                                            self.font[0],
                                                            96,
                                                            self.current_size_scr[0]//2,
                                                            self.current_size_scr[1]//2 +100),'play_btn')

        self.sprids['menu']['quickplay_btn'] = self.specMan.addThg(drawable.LabelButton(self.all_in_one,(300,70),'QUICKPLAY',
                                                            self.font[0],
                                                            70,
                                                            self.current_size_scr[0]//2,
                                                            200,
                                                            param='quickplay'),'quickplay_btn')

        self.sprids['menu']['resume_btn'] = self.specMan.addThg(drawable.LabelButton(self.navigate,(300,100),'RESUME',
                                                            self.font[0],
                                                            96,
                                                            self.current_size_scr[0]//2,
                                                            self.current_size_scr[1]//2 +100,
                                                            param='showing'),'resume_btn')

        self.sprids['menu']['quit_btn'] = self.specMan.addThg(drawable.LabelButton(self.get_out,(300,100),'QUIT',
                                                            self.font[1],
                                                            96,
                                                            self.current_size_scr[0]//2,
                                                            self.current_size_scr[1]//2 -150),'quit_btn')

        self.sprids['menu']['main_menu_btn'] = self.specMan.addThg(drawable.LabelButton(self.quit_land,(300,100),'MAIN',
                                                            self.font[0],
                                                            96,
                                                            self.current_size_scr[0]//2,
                                                            self.current_size_scr[1]//2 -400),'main_menu_btn')

        self.sprids['menu']['return_btn'] = self.specMan.addThg(drawable.LabelButton(self.navigate,(200,50),'RETURN',
                                                            self.font[1],
                                                            70,
                                                            3*(self.current_size_scr[0]//4),
                                                            80,(False,'menu')),'return_btn')

        self.sprids['menu']['new_map_btn'] = self.specMan.addThg(drawable.LabelButton(self.navigate,(250,50),'CREATE MAP',
                                                            self.font[0],
                                                            70,
                                                            self.current_size_scr[0]//4,
                                                            80,
                                                            param=('newmap','menu')),'new_map_btn')

        self.sprids['menu']['create_btn'] = self.specMan.addThg(drawable.LabelButton(self.all_in_one,(250,50),'CREATE',
                                                            self.font[0],
                                                            70,
                                                            self.current_size_scr[0]//4,
                                                            80,
                                                            param='creating'),'create_btn')

        self.sprids['menu']['chargement_desc'] = self.specMan.addLabel('... LOADING MAP ASPECTS ...',
                                                            self.font[2],
                                                            30,
                                                            self.current_size_scr[0]//2,
                                                            20,'chargement_desc')


        v = gs.get_version(self.path)
        text = '__ DELTAWORLD version  '+ v + ' __'

        self.sprids['menu']['description'] = self.specMan.addLabel(text.upper(),
                        self.font[2],
                        30,
                        self.current_size_scr[0]//2,
                        20,'description')


        ## WRITTING BAR


        self.sprids['menu']['new_map_wrtgbar'] = self.specMan.addThg(drawable.WritingBar(self.verify_name,(300,100),'enter name here',
                                                            self.font[0],
                                                            96,
                                                            self.current_size_scr[0]//2,
                                                            self.current_size_scr[1]//2),'new_map_wrtgbar')

        self.text_size_land_menu = ['HOLY SHIT IT\'S TOO SMALL 1*1','MINUS 4*4','SMALL 8*8','NORMAL 10*10','FAT 12*12','HUGE 20*20','LEGEND 30*30','hmm.. SERIOUS ? 50*50']
        self.text_size_land_menu_colors = [(50, 225, 175,255),(150,255,150,255),(100,100,255,255),(75,75,75,255),(35,35,35,255),(0,0,0,255),(50, 175, 225,255),(200,100,100,255)]
        self.text_size_land_menu_val = [(1,1),(4,4),(8,8),(10,10),(12,12),(20,20),(30,30),(50,50)]
        self.text_size_land_menu_sel = 0

        self.sprids['menu']['size_land'] = self.specMan.addLabel(self.text_size_land_menu[self.text_size_land_menu_sel],
                                            self.font[0],
                                            96,
                                            self.current_size_scr[0]//2,
                                            self.current_size_scr[1]//2-250,'size_land',self.text_size_land_menu_colors[self.text_size_land_menu_sel])

        self.sprids['menu']['up_size_btn'] = self.specMan.addThg(drawable.LabelButton(self.change_size_land,(75,75),'-',
                                                            self.font[0],
                                                            100,
                                                            self.current_size_scr[0]//4-125,
                                                            self.current_size_scr[1]//2-200,param=False,nobig=True),'up_size_btn')

        self.sprids['menu']['down_size_btn'] = self.specMan.addThg(drawable.LabelButton(self.change_size_land,(75,75),'+',
                                                            self.font[0],
                                                            100,
                                                            3*(self.current_size_scr[0]//4)+125,
                                                            self.current_size_scr[1]//2-200,nobig=True),'down_size_btn')

        ## DECLARATION DES BOUTTONS A AFFICHER LORS DES DIFF MENUS


        self.buttons['main'] = ['play_btn','quit_btn','quickplay_btn']
        self.buttons['maps'] = ['return_btn','new_map_btn']
        self.buttons['newmap'] = ['return_btn','new_map_wrtgbar','create_btn','up_size_btn','down_size_btn']
        self.buttons['pause'] = ['resume_btn','quit_btn','main_menu_btn']



    ### MAIN FUNCTIONS

    def navigate(self,level,threw='game'):

        #print(self.action_menu)

        if threw == 'game':
            if type(level) == type('sdq') and level != self.actions[self.action]:
                while self.actions[self.action] != level:
                    self.action +=1
                    if self.action >= len(self.actions):
                        self.action=0

            elif type(level) == type(True):
                if level:
                    self.action += 1
                    if self.action >= len(self.actions):
                        self.action=0
                else:
                    self.action -= 1
                    if self.action < 0:
                        self.action=len(self.actions)-1
            elif type(level) == type(self.action):
                self.action = level

            #print(self.actions[self.action])

        elif threw == 'menu':


            if type(level) == type('sdq'):
                while self.actions_menu[self.action_menu] != level:
                    self.action_menu += 1
                    if self.action_menu >= len(self.actions_menu):
                        self.action_menu = 0

            elif type(level) == type(True):
                if level:
                    self.action_menu += 1
                    if self.action_menu >= len(self.actions_menu):
                        self.action_menu=0
                else:
                    self.action_menu -= 1
                    if self.action_menu < 0:
                        self.action_menu=len(self.actions_menu)-1

            else:
                self.action_menu = level
            #print(self.action_menu)
            if self.actions_menu[self.action_menu] == 'newmap':
                #print('okilm')
                self.effectMan.unhide('blur70_newland',False)
            else:
                self.effectMan.unhide('blur70_newland',True)

        #print(self.action_menu)

    def all_in_one(self,style,plus=None):

        name = ''

        if style == 'creating':
            if not self.specMan.to_draw['new_map_wrtgbar'].validated:
                print('Name already in use !! you can\'t create antoher land like that !')
                return 0
            else:

                self.effectMan.unhide('blur70_newland',True)
                name = self.specMan.to_draw['new_map_wrtgbar'].text
                self.specMan.to_draw['new_map_wrtgbar'].put_to_zero()

        if style == 'loading' or style == 'quickplay':
            global TAKE_DIRECT_SCREEN,SAVES_PATH
            TAKE_DIRECT_SCREEN = False

            if style == 'loading':
                name = plus
            else:
                name = 'quickplay'


        self.loading = {'name':name}
        self.load_to_do = ['extracting game data',
                        'initialisation of loading',
                        'initialisating sprites and labels',
                        'loading persos',
                        'initialisating hud elements',
                        'initialisating camera',
                        'creating sprites', #GE
                        'creating blur effect map',
                        'resetting camera',
                        'finishing loading',
                        ]
        self.loading['style'] = style

        if style == 'quickplay':

            SAVES_PATH = '/'
            if self.verify_name('quickplay'):
                self.loading['style'] = 'creating'
                self.loading['size'] = (1,1)
            else:
                self.loading['style'] = 'loading'
        elif style == 'creating':

            self.loading['size'] = None

        if self.loading['style'] == 'creating':

            self.creating = {}
            self.create_to_do = ['initialisating creation',
                                'choosing zones',
                                'choosing grounds',
                                'creating noise',
                                'coloring terrain', #GE
                                'placing assets', #GE
                                'verifing terrain',
                                'splitting terrain',
                                'creating persos',
                                'creating bots', #GE
                                'finishing creating',
                                ]
            self.creating['state'] = 0
            self.loading['state'] = 1

            #print(len(self.create_to_do))

        else:
            self.loading['state'] = 0


        self.loading['aff_map'] = [1,1]

        if style == 'quickplay':
            self.loading['aff_map'] = [0,1]


        anc = [*pup.POS['loading_bar']]
        size_lifebar = pup.SIZ['loading_bar'][0]

        self.sprids['loading'] = {}
        self.sprids['loading']['l'] = self.graphic.addSpr(self.textids['hud'][3],anc)
        self.sprids['loading']['r'] = self.graphic.addSpr(self.textids['hud'][3],(anc[0]+size_lifebar,anc[1]))
        self.sprids['loading']['mid'] = self.graphic.addSpr(self.textids['hud'][2],anc)
        self.graphic.modify(self.sprids['loading']['mid'],scale=(size_lifebar/SIZE_TILE,1))
        self.graphic.addToGroup(self.sprids['loading']['l'],['map'],2)
        self.graphic.addToGroup(self.sprids['loading']['r'],['map'],2)
        self.graphic.addToGroup(self.sprids['loading']['mid'],['map'],2)

        self.sprids['loading']['fill'] = self.graphic.addSpr(self.textids['hud'][5],anc)
        self.graphic.modify(self.sprids['loading']['fill'],scale=(0,1))
        self.graphic.addToGroup(self.sprids['loading']['fill'],['map'],1)


        self.loadbar = {}
        self.loadbar['percent'] = 0
        self.loadbar['plus'] = ''

        self.loadbar['nb_ope'] = len(self.load_to_do)
        if self.loading['style'] == 'creating':
            self.loadbar['nb_ope']+= len(self.create_to_do)
            self.loadbar['nb_ope']-=1

        pos = pup.GEN['ax']/2,anc[1]+pup.SIZ['loading_bar'][1]
        self.lblids['loading'] = self.labman.addLabel(self.load_to_do[self.loading['state']],pos \
                        ,font_size=32*pup.GEN['1y'],font_name=self.font[0],anchor=('center','bottom'),color=(0,0,0,255))

        self.labman.addToGroup(self.lblids['loading'],['map'],2)


        self.all_times = {}
        for todo in self.load_to_do:
            self.all_times[todo] = 0
        if self.loading['style'] == 'creating':
            del self.all_times['extracting game data']
            for todo in self.create_to_do:
                self.all_times[todo] = 0

        self.total_time_loading = time.time()

        self.navigate(self.loading['style'])


    ### IN MENU : SELECTION LAND

    def choice_land(self):


        ## DRAW MAPS CHOICES


        # search all lands
        self.all_lands = []

        #verify the existence of saves directory
        if SAVES_PATH[1:-1] not in os.listdir():
            os.makedirs(self.path+SAVES_PATH)

        #adding all lands
        cmdd = os.popen('dir '+self.path+'\\'+SAVES_PATH[1:-1] +' /B /TA /O-D',)
        #print('dir '+self.path+'\\'+SAVES_PATH[1:-1] +' /B /TA /O-D')
        total = cmdd.read().split('\n')
        cmdd.close()
        #print(total)

        for name in total:
            self.all_lands.append(name)



        not_a_land = []
        #print('all_lands',self.all_lands)
        for name in self.all_lands:
            try:
                with open(self.path+SAVES_PATH+name+'/perso','r'):
                    #print(name,'successful')
                    a=0
            except:
                not_a_land.append(name)
                #print(name,'not there')

        for name in not_a_land:
            self.all_lands.remove(name)


        # creating btns
        self.buttons['maps'] = ['return_btn','new_map_btn']

        for name in self.sprids['menu']['all_maps']:
            self.specMan.to_draw[self.sprids['menu']['all_maps'][name]].delete()

        self.sprids['menu']['all_maps']={}

        self.defil_menu = 0

        if len(self.all_lands) > 5:

            self.sprids['menu']['defil_btn_R'] = self.specMan.addThg(drawable.LabelButton(self.defil_lands,(200,200),'>',
                                                                self.font[0],
                                                                96,
                                                                4*self.current_size_scr[0]//5,
                                                                self.current_size_scr[1]//2,
                                                                param=1),'defil_btn_R')
            self.sprids['menu']['defil_btn_L'] = self.specMan.addThg(drawable.LabelButton(self.defil_lands,(200,200),'<',
                                                                self.font[0],
                                                                96,
                                                                self.current_size_scr[0]//5,
                                                                self.current_size_scr[1]//2,
                                                                param=-1),'defil_btn_L')
            self.buttons['maps'].append('defil_btn_R')
            self.buttons['maps'].append('defil_btn_L')

        if self.all_lands == []:

            self.sprids['menu']['all_maps']['map'+str(0)+'_btn'] = self.specMan.addLabel('NO MAPS',
                                                                self.font[0],
                                                                96,
                                                                self.current_size_scr[0]//2,
                                                                self.current_size_scr[1]//2,'map'+str(0)+'_btn')
            self.buttons['maps'].append('map'+str(0)+'_btn')
        else:
            for i in range(len(self.all_lands)):
                self.sprids['menu']['all_maps']['map'+str(i)+'_btn'] = self.specMan.addThg(drawable.LabelButton(self.all_in_one,(200,60),self.all_lands[i],
                                                            self.font[0],
                                                            70,
                                                            self.current_size_scr[0]//2,
                                                            self.current_size_scr[1]//2 +200 - (i%5)*150,
                                                            param=['loading',self.all_lands[i]]),'map'+str(i)+'_btn')
                if i < 5:
                    self.buttons['maps'].append('map'+str(i)+'_btn')

        self.navigate(1,'menu')

    def defil_lands(self,n):
        self.defil_menu += n
        if self.defil_menu <0:
            self.defil_menu = len(self.all_lands)//5
        elif self.defil_menu > len(self.all_lands)//5:
            self.defil_menu = 0
        self.buttons['maps'] = ['return_btn','new_map_btn','defil_btn_R','defil_btn_L']

        for i in range(self.defil_menu*5,len(self.all_lands)):
            if i< self.defil_menu*5 + 5:
                self.buttons['maps'].append('map'+str(i)+'_btn')

        #print(self.buttons['maps'])

    def change_size_land(self,plus=True):

        #print('plus',plus)
        key = self.text_size_land_menu_sel
        if plus:
            key+=1
            if key >= len(self.text_size_land_menu):
                key=0
        else:
            key-=1
            if key < 0:
                key=len(self.text_size_land_menu)-1
        self.text_size_land_menu_sel = key
        self.sprids['menu']['size_land'] = self.specMan.addLabel(self.text_size_land_menu[key],
                                                self.font[0],
                                                96,
                                                self.current_size_scr[0]//2,
                                                self.current_size_scr[1]//2-250,'size_land',self.text_size_land_menu_colors[key])

    def verify_name(self,name):

        ## renvoie True si il n'y a pas déjà de map avec ce nom
        ## False sinon

        try :
            f = open(self.path+SAVES_PATH+name+'/perso','r')
            f.close()
            return False
        except:
            return True


    ### IN LOADING : CREATING/LOADING T4ABS

    def load_land(self,name):

        #name = self.terrain.name

        elapsed_time = time.time()
        # LOADING TERRAIN

        tab_perso = []
        tab_map = []
        tab_land = []

        with open(self.path+SAVES_PATH+name+'/perso','r') as f:
            tab_perso = json.load(f)

        with open(self.path+SAVES_PATH+name+'/card','r') as f:
            tab_map = json.load(f)

        #self.terrain.Bioms = []
        with open(self.path+SAVES_PATH+name+'/land','r') as f:
            tab_land = json.load(f)


        print('   -CHARGEMENT DU TERRAIN :',truncate((time.time() - elapsed_time),3))
        #print(tab_perso,'\n', tab_map ,'\n', tab_land,'\n', name)
        return tab_perso, tab_map , tab_land, name


    ### IN LOADING : USING T4ABS

    def create_biom_sprites(self,biom):


        i,j = biom

        for lvl in range(len(self.terrain.Bioms[j][i].ground)):
            for y in range(len(self.terrain.Bioms[j][i].ground[lvl])):
                for x in range(len(self.terrain.Bioms[j][i].ground[lvl][y])):
                    #print(self.terrain.Bioms[j][i].ground[lvl])
                    if self.terrain.Bioms[j][i].ground[lvl][y][x] != 0:

                        #posx = self.admin_cam[0] -self.camera[0] + self.cursor_x +tut.SIZE_TILE[0]*x + i*tut.SIZE_BIOM[0]*tut.SIZE_TILE[0]
                        #posy = self.admin_cam[1] -self.camera[1] + self.cursor_y + tut.Y_DEP - tut.SIZE_TILE[0]*y + tut.Y_DEP_BIOM - j*tut.SIZE_BIOM[1]*tut.SIZE_TILE[0]

                        #print(tut.from_bcx_to_xy(tut.BCX_Pos((i,j),(x,y))))
                        #print(tut.from_pxpos_to_realpos( tut.from_bcx_to_xy(tut.BCX_Pos((i,j),(x,y)))))
                        pos = tut.from_bcx_to_pxx((i,j),(x,y))
                        #print( (posx,posy) == pos.xy()  )

                        self.sprids['bioms'][i,j][lvl][x,y] = self.graphic.addSpr(self.textids['ground'][self.terrain.Bioms[j][i].ground[lvl][y][x]],pos,vis=False)
                        #print(self.sprids['bioms'][i,j][x,y])
                        if not (i,j) in self.bioms_to_print:
                            self.graphic.sprites[self.sprids['bioms'][i,j][lvl][x,y]].visible=False
                        self.graphic.addToGroup(self.sprids['bioms'][i,j][lvl][x,y],[None,None,lvl])

    ### AFTER PLAYING : SAVE, QUITING LAND

    def save_land(self):

        #t = [1,1,1,1,0,0,{}]
        elapsed_time = time.time()
        success = True


        tab_perso = []

        for perso in self.persos:

            dic = {}

            dic['name'] = self.persos[perso].name
            dic['life'] = (self.persos[perso].life,self.persos[perso].max_life)

            dic['pos'] = []
            for x in self.persos[perso].pos.bcx():
                dic['pos']+= [*x]
            dic['pos']+= [self.persos[perso].pos.lvl()]

            if type(self.persos[perso]) == pso.Perso:
                dic['type'] = 'Perso'
            else:
                dic['type'] = 'Living'

            dic['specie'] = self.persos[perso].specie
            dic['skin_dic'] = self.persos[perso].skin_dic

            if perso == self.perso:
                dic['inventory'] = self.persos[perso].get_inv()
                dic['main'] = True
            else:
                dic['main'] = False

            dic['id'] = perso

            tab_perso.append(dic)

        try :
            with open(self.path+SAVES_PATH+self.terrain.name+'/perso','w') as f:
                json.dump(tab_perso,f)
        except:
            os.makedirs(self.path+SAVES_PATH+self.terrain.name)
            with open(self.path+SAVES_PATH+self.terrain.name+'/perso','w') as f:
                json.dump(tab_perso,f)

        otre_save_path = SAVES_PATH[1:-1]

        os.system('mkdir '+self.path+'\\'+otre_save_path+'\\'+self.terrain.name+ '\\t') #afin de mettre la map en dernière modifiée
        os.system('rmdir '+self.path+'\\'+otre_save_path+'\\'+self.terrain.name+ '\\t')

        with open(self.path+SAVES_PATH+self.terrain.name+'/card','w') as f:
            json.dump(self.terrain.map,f)
        with open(self.path+SAVES_PATH+self.terrain.name+'/land','w') as f:
            terrain = []
            for j in range(len(self.terrain.Bioms)):
                rangey = []
                for i in range(len(self.terrain.Bioms[j])):
                    biom = self.terrain.Bioms[j][i]
                    biom_ter = []
                    for lvl in range(len(biom.ground)):
                        biom_ter.append(biom.ground[lvl])

                    """if i == 0 and j == 0:
                        print(biom_ter)"""
                    rangey.append(biom_ter)
                terrain.append(rangey)
                #f.write('\n')
            json.dump(terrain,f)
            #print(terrain)


        print('   -SAUVEGARDE DE LA PARTIE :',truncate((time.time() - elapsed_time),3))
        """if success:
            print('La partie',self.terrain.name,'a bien été sauvegardée')
        else:
            print('Echec de sauvegarde de',self.terrain.name)"""

    def quit_land(self,save=True):
        global SAVES_PATH

        self.navigate('menu')
        self.navigate('main','menu')
        if save:
            self.save_land()

        # on efface tous les sprites qui ne sont pas statiques ni effets
        self.graphic.delete()
        #print(self.graphic.sprites)

        #print(get_key_from_values(self.sprids,errors))

        if 'inventory_hud' in self.sprids:
            self.graphic.unhide(self.sprids['inventory_hud'],True)

        if self.effectMan.hasEffect('blur50_map'):
            self.effectMan.unhide('blur50_map',True)


        if hasattr(self, 'creating'):
            del self.creating
            del self.create_to_do
            del self.loading
            del self.load_to_do
            self.graphic.delete(self.sprids['loading'])
            self.labman.delete(self.lblids['loading'])
            del self.sprids['loading']
            del self.lblids['loading']

        elif hasattr(self, 'loading'):
            del self.loading
            del self.load_to_do
            self.graphic.delete(self.sprids['loading'])
            self.labman.delete(self.lblids['loading'])
            del self.sprids['loading']
            del self.lblids['loading']


        #print(errors)

        # on efface les labels du hud qui étaient affichés
        #print(self.lblids)
        self.labman.delete(self.lblids['hud'])

        # on supprime le terrain
        self.terrain = terrain.TerManager(0,0,None)

        # on supprime les persos
        self.persos = {}

        # on supprime les ids de sprites en mémoire
        self.sprids['persos'] = {}
        self.sprids['bioms'] = {}
        self.sprids['map'] = {}
        self.sprids['hud'] = {}

        # on supprime les ids de labels en mémoire
        self.lblids['hud'] = {}

        SAVES_PATH = '/saves/'
        self.in_land = False

        #print(self.actions[self.action])

    ### ONCE FUNCTIONS

    def create_image(self):
        global TAKE_DIRECT_SCREEN

        print('creation de l\'image')
        elapsed_time = time.time()
        bigmap = pil.Image.new('RGBA',(tut.SIZE_TILE[0]*tut.SIZE_BIOM[0]*tut.SIZE_TERRAIN[0],tut.SIZE_TILE[1]*tut.SIZE_BIOM[1]*tut.SIZE_TERRAIN[1]),(0,0,0,0))

        for j in range(tut.SIZE_TERRAIN[1]):
            for i in range(tut.SIZE_TERRAIN[0]):
                #print(i,j)
                for lvl in range(tut.DEPTH_BIOM):
                    #print('   ',lvl)
                    for y in range(tut.SIZE_BIOM[1]):
                        for x in range(tut.SIZE_BIOM[0]):

                            bcx_pos = tut.BCX_Pos((i,j),(x,y),l=lvl)
                            if self.terrain.get_case(bcx_pos) != 0:
                                xx,yy = tut.from_bcx_to_xy(bcx_pos).xy()
                                data = self.manager.rawdata[self.textids['ground'][self.terrain.get_case(bcx_pos)]]
                                im = pil.Image.frombytes('RGBA', tut.SIZE_TILE, data)
                                #print(xx,yy)
                                bigmap.alpha_composite(im,(xx,yy))

        """try :
            with open(self.path+SAVES_PATH+self.terrain.name+'/perso','w') as f:
                a=0
        except:
            os.makedirs(self.path+SAVES_PATH+self.terrain.name)"""

        if self.terrain.name not in os.listdir(self.path+SAVES_PATH):
            os.makedirs(self.path+SAVES_PATH+self.terrain.name+'/')

        #imag_path = self.path+SAVES_PATH+'maps/'

        bigmap = bigmap.transpose(pil.Image.FLIP_TOP_BOTTOM)
        ## Z:\DESKTOP\CODING\delta2D\saves\maps\genv3
        if TAKE_DIRECT_SCREEN:
            TAKE_DIRECT_SCREEN = False

        bigmap.save(self.path+SAVES_PATH+self.terrain.name+'/'+self.terrain.name+'.png')

        print('   -CREATION DU SCREENSHOT :',truncate((time.time() - elapsed_time),3))
        print(self.terrain.name+'.png','saved well')

    def nothing(self):
        a=0

    def get_out(self):
        if self.in_land:
            #self.create_image()
            self.save_land()
        self.playing = False

    def verif(self,biom):

        err = 0
        for lvl in range(len(self.terrain.Bioms[biom[1]][biom[0]].ground)):
            for y in range(len(self.terrain.Bioms[biom[1]][biom[0]].ground[lvl])):
                for x in range(len(self.terrain.Bioms[biom[1]][biom[0]].ground[lvl][y])):

                    case = False
                    spr = False
                    if self.terrain.get_case(tut.BCX_Pos(biom,(x,y)),lvl) != 0:
                        case = True
                    if self.sprids['bioms'][biom][lvl][(x,y)] != 0:
                        spr = True

                    if not spr==case:
                        err += 1
                        print('verif',biom,':  lvl',lvl,'xy',x,y,'   case',self.terrain.get_case(tut.BCX_Pos(biom,(x,y)),lvl),'  spr',self.sprids['bioms'][biom][lvl][(x,y)] ,'  ',spr==case )
        print('verif biom',biom,':',err,'errors')

    def clear_sprites(self,biom):

        #self.verif(biom)

        i,j = biom
        for lvl in self.sprids['bioms'][i,j]:
            for cas in self.sprids['bioms'][i,j][lvl]:
                if self.sprids['bioms'][i,j][lvl][cas] != 0:
                    self.graphic.delete(self.sprids['bioms'][i,j][lvl][cas])

        self.sprids['bioms'][i,j] = {}
        for lvl in range(tut.DEPTH_BIOM):
            self.sprids['bioms'][i,j][lvl] = {}
            for x in range(tut.SIZE_BIOM[0]):
                for y in range(tut.SIZE_BIOM[1]):
                    self.sprids['bioms'][i,j][lvl][x,y] = 0

    def reset_camera(self,dir):

        #objx , objy = self.camera_obj
        objx , objy = self.camera.obj.xy()
        #objtilex,objtiley = self.camera_obj_tile

        if 'x' in dir:

            if self.persos[self.perso].px_pos.x > self.camera.pos.x:
                delta = self.current_size_scr[0]//6
            else:
                delta = -self.current_size_scr[0]//6

            objx = self.persos[self.perso].px_pos.x+delta
            #objtilex = [self.persos[self.perso].pos.x[0],self.persos[self.perso].pos.x[1],self.persos[self.perso].pos.x[2]]

        if 'y' in dir:

            if self.persos[self.perso].px_pos.y > self.camera.pos.y:
                delta = self.current_size_scr[1]//6
            else:
                delta = -self.current_size_scr[1]//6

            objy = self.persos[self.perso].px_pos.y+delta
            #objtiley = [self.persos[self.perso].pos.y[0],self.persos[self.perso].pos.y[1],self.persos[self.perso].pos.y[2]]

        if 'ulti' in dir:

            objx = self.persos[self.perso].px_pos.x
            objy = self.persos[self.perso].px_pos.y
            #objtilex = [thg[0] for thg in self.persos[self.perso].pos.bcx()]
            #objtiley = [thg[1] for thg in self.persos[self.perso].pos.bcx()]
            #self.camera_tile = [objtilex,objtiley]

        self.camera.obj = tut.XY_Vec(objx,objy)
        #self.camera_obj = [objx,objy]
        #self.camera_obj_tile = [objtilex,objtiley]

    def reset_biom(self,biom):

        i,j = biom
        self.clear_sprites((i,j))

        #biom = terrain.emptyBiom(tut.SIZE_BIOM)
        #choice = random.choice(range(len(self.saved_terrains)))
        #biom.ground = modifyPlatform(self.saved_terrains[choice],(tut.SIZE_BIOM[0]-1),(tut.SIZE_BIOM[1]-1))
        #print(biom.ground)

        #p,map,biom,n = self.create_land('',(1,1))
        map,biom = createMap((1,1),tut.SIZE_BIOM,tut.DEPTH_BIOM,style=1)
        #print(biom[0][0])
        biom = terrain.Biom(biom[0][0])
        #print(self.terrain.Bioms[j][i].ground)

        self.terrain.set_Biom(i,j,biom,map[0][0])

        self.generated_terrains+=1
        print(self.generated_terrains,'generated bioms')

        for lvl in range(len(self.terrain.Bioms[j][i].ground)):
            for y in range(len(self.terrain.Bioms[j][i].ground[lvl])):
                for x in range(len(self.terrain.Bioms[j][i].ground[lvl][y])):
                    if self.terrain.Bioms[j][i].ground[lvl][y][x] != 0:

                        #posx = self.admin_cam[0] -self.camera[0] + self.cursor_x +tut.SIZE_TILE[0]*x + i*tut.SIZE_BIOM[0]*tut.SIZE_TILE[0]
                        #posy = self.admin_cam[1] -self.camera[1] + self.cursor_y + tut.Y_DEP - tut.SIZE_TILE[0]*y + tut.Y_DEP_BIOM - j*tut.SIZE_BIOM[1]*tut.SIZE_TILE[0]

                        pos = tut.from_bcx_to_pxx((i,j),(x,y))
                        #print( (posx,posy) == pos.xy()  )

                        self.sprids['bioms'][i,j][lvl][(x,y)] = self.graphic.addSpr(self.textids['ground'][self.terrain.Bioms[j][i].ground[lvl][y][x]],pos)
                        self.graphic.addToGroup(self.sprids['bioms'][i,j][lvl][x,y],[None,None,lvl])

        # reset map miniature
        self.graphic.delete(self.sprids['map'][i,j])
        self.sprids['map'][i,j] = self.graphic.addSpr(self.textids['ground'][self.terrain.map[j][i]],tut.get_pos_map_biom((i,j),self.current_size_scr),vis=self.aff_map[0])
        self.graphic.addToGroup(self.sprids['map'][i,j],['map'])

        #self.start_playing()

        #self.verif((i,j))

    def selector_modify(self,pos,btn,test=False,val=-1):

        pos = tut.from_real_to_pxpos(tut.XY_Pos(*pos))
        b,c,p = tut.from_xy_to_bcx(pos).bcx()

        valfin = None

        if not test:
            if self.selector[2] == btn and self.selector[1] == [b,c] and val== -1:
                self.selector[0] += 1
            elif val != -1:
                self.selector[0] = val
            else:
                self.selector = [0,[b,c],btn]

            time_nec = self.persos[self.perso].get_action_time(btn)
            if self.selector[0] >= time_nec:
                self.persos[self.perso].act(pos,btn)
                self.selector[0] = 0

            instant = (time_nec/8)
            if instant != 0:
                nb_skin = int(self.selector[0]//instant)
                valfin = nb_skin
                if nb_skin != (self.selector[0]-1)//(time_nec/8):
                    if (b,c) in self.sprids['cursors']['select']:
                        self.sprids['cursors']['select'][b,c].set_text(16+nb_skin)
                        #self.graphic.set_text(self.sprids['cursors']['select'][(b,c)],self.textids['effects'][16+nb_skin])
            else:
                if (b,c) in self.sprids['cursors']['select']:
                    if self.clicks[btn] != False:
                        self.sprids['cursors']['select'][b,c].set_text(16+7)
                        valfin = 7
                        #self.graphic.set_text(self.sprids['cursors']['select'][(b,c)],self.textids['effects'][16+7])
                    else:
                        self.sprids['cursors']['select'][b,c].set_text(16)
                        valfin = 0
                        #self.graphic.set_text(self.sprids['cursors']['select'][(b,c)],self.textids['effects'][16])

        else:

            valfin = None
            if not self.selector[1] == [b,c]:
                self.selector[0],self.selector[1] = 0,[b,c]

        return (b,c),valfin

    def get_current_screen(self):

        x,y = self.get_location()
        for i in range(len(self.screens)):
            scr = self.screens[i]
            if (x >= scr.x and x <= scr.x + scr.width) and (y >= scr.y and y <= scr.y + scr.height):
                return scr
        return self.screens[0]


    # ONCE FUNCTIONS GAMEPLAY

    def init_hud(self):

        """
        ELEMENTS DU HUD:

            -Nom du perso
            -Barre de vie

        +Nametags

        """

        anc = pup.POS['hud_healthbar']

        size_lifebar = SIZE_TILE*(self.persos[self.perso].max_life/10)
        size_fill = SIZE_TILE*(self.persos[self.perso].life/10)

        self.sprids['hud']['life_bar'] = {}
        self.sprids['hud']['life_bar']['l'] = self.graphic.addSpr(self.textids['hud'][3],anc,vis=self.aff_hud)
        self.sprids['hud']['life_bar']['r'] = self.graphic.addSpr(self.textids['hud'][3],(anc[0]+size_lifebar,anc[1]),vis=self.aff_hud)
        self.sprids['hud']['life_bar']['mid'] = self.graphic.addSpr(self.textids['hud'][2],anc,vis=self.aff_hud)
        self.graphic.modify(self.sprids['hud']['life_bar']['mid'],scale=(size_lifebar/SIZE_TILE,1))
        self.graphic.addToGroup(self.sprids['hud']['life_bar']['l'],['hud'])
        self.graphic.addToGroup(self.sprids['hud']['life_bar']['r'],['hud'])
        self.graphic.addToGroup(self.sprids['hud']['life_bar']['mid'],['hud'])

        self.sprids['hud']['life_bar']['fill'] = self.graphic.addSpr(self.textids['hud'][4],anc,vis=self.aff_hud)
        self.graphic.modify(self.sprids['hud']['life_bar']['fill'],scale=(size_fill/SIZE_TILE,1))
        self.graphic.addToGroup(self.sprids['hud']['life_bar']['fill'],['hud'],-1)


        diff = 1*pup.GEN['1y'] # difference de hauteur
        pos = (anc[0],anc[1]+self.graphic.spr(self.sprids['hud']['life_bar']['l']).height+diff)
        self.lblids['hud']['perso_name'] = self.labman.addLabel(self.persos[self.perso].name,pos,vis=self.aff_hud,font_size=32*pup.GEN['1y'],font_name=choice(self.font))
        self.labman.addToGroup(self.lblids['hud']['perso_name'],['hud'],1)
        #self.labman.unhide(self.lblids['hud']['perso_name'],True)

    def actualise_hud(self):

        anc = pup.POS['hud_healthbar']

        size_lifebar = SIZE_TILE*(self.persos[self.perso].max_life/10)
        size_fill = SIZE_TILE*(self.persos[self.perso].life/10)


        self.graphic.unhide(self.sprids['hud'],not self.aff_hud)
        self.labman.unhide(self.lblids['hud'],not self.aff_hud)
        self.labman.set_text(self.lblids['hud']['perso_name'],self.persos[self.perso].name)
        self.graphic.modify(self.sprids['hud']['life_bar']['r'],(anc[0]+size_lifebar,anc[1]))
        self.graphic.modify(self.sprids['hud']['life_bar']['fill'],scale=(size_fill/SIZE_TILE,1))
        self.graphic.modify(self.sprids['hud']['life_bar']['mid'],scale=(size_lifebar/SIZE_TILE,1))

    def game_over(self):
        print('game over sale noob')
        #self.navigate('gameover')

    ### PYGLET FUNCTIONS

    def on_key_press(self,symbol,modifiers):

        if not (self.actions[self.action] == 'menu' and self.actions_menu[self.action_menu] == 'newmap' and self.specMan.to_draw['new_map_wrtgbar'].selected):

            #toggle fullscreen
            if symbol == key.F11:
                #print(self.fscreen)
                if self.fscreen:
                    self.fscreen = False
                    self.set_fullscreen(False)
                    self.set_size(self.size_scr[0],self.size_scr[1])
                    self.current_size_scr = self.size_scr
                    self.on_my_resize()
                else:
                    self.fscreen = True
                    used_screen=self.get_current_screen()
                    self.set_fullscreen(screen=used_screen)
                    self.size_fullscr = [used_screen.width,used_screen.height]
                    self.current_size_scr = self.size_fullscr
                    self.on_my_resize()

                self.nb_spr_to_draw = [(self.current_size_scr[0]+32*2)//32,(self.current_size_scr[1]+32*2)//32]

            #toggle the cmd
            elif symbol == key.LALT:
                self.aff_cmd = not self.aff_cmd

            #toggle target
            elif symbol == key.T:
                self.aff_target = not self.aff_target
                self.graphic.unhide(self.sprids['target'],not self.aff_target)

            #defil mode (un peu broken)
            elif symbol == key.A:
                if False:

                    if self.keys[key.LSHIFT]:
                        self.action -= 1
                        if self.action < 0:
                            self.action = len(self.actions) - 1

                    else:
                        self.action += 1
                        if self.action >= len(self.actions):
                            self.action = 0

                    print(self.actions[self.action])
                    self.cmd.add(' ',self.actions[self.action])

            #affiche les différents OrderedGroup d'affichage
            elif symbol == key.G:

                print('\nYOU ASKED TO PRINT GROUPS AND THEIR ORGANISATION:')

                print('  will be displayed in descending order like that : order,name\n')

                tab = []

                orders_sorted = sorted(self.group_manager.names_wo,reverse=True)

                for order in orders_sorted:

                    say = str(order)
                    say += (6-len(say))*' '
                    say +=self.group_manager.names_wo[order]
                    print(say)
                print('')

            #renouvelle les effets
            elif symbol == key.M:
                a=0
                self.create_effects()

            #print la position de la souris
            elif symbol == key.K:
                print(self.clicks['M'])

            #affiche quel écran est utilisé
            elif symbol == key.L:
                print('screen :',self.get_current_screen())
                print('size :',self.get_size())


            elif self.in_land:
                #cree un screenshot de la map entière
                if symbol == key.F3:
                    self.create_image()

                #ajoute enleve de la vie au perso aleatoirement
                elif symbol == key.V:
                    self.persos[self.perso].adelife((random.random()*2 -1)*self.persos[self.perso].max_life)

                #ajoute enleve de la maxvie au perso aleatoirement
                elif symbol == key.B:
                    self.persos[self.perso].adelife_max((random.random() -0.5)*20)

                elif symbol == key.R:

                    self.persos[self.perso].name = input('\nEntrez un nouveau nom pour le personnage : ')

                elif symbol == key.N:

                    print('nothing yet')


        if self.actions[self.action] == 'showing' or self.actions[self.action] == 'showing2' :

            if symbol == key.ESCAPE:
                self.navigate('pause','menu')
                self.navigate('menu')

            elif symbol == key.TAB:
                self.aff_map[0] = not self.aff_map[1]

            elif symbol == key.U:
                self.admin_cam.pos = tut.XY_Vec(0,0)

            elif symbol == key.W:
                for pers in self.persos:
                    self.persos[pers].show_line = not self.persos[pers].show_line
                    for typ in self.sprids['persosplus']:
                        for sprid in self.sprids['persosplus'][typ]:
                            self.graphic.unhide(sprid,not self.persos[pers].show_line)

            elif symbol == key.I:
                #print(self.persos[self.perso].aff_inv)
                self.graphic.unhide(self.sprids['inventory_hud'],self.persos[self.perso].aff_inv)
                self.sprids['cursors']['invent_select'].unhide(self.persos[self.perso].aff_inv)
                if not self.persos[self.perso].aff_inv:
                    if self.selection == 'inventory':
                        for thg in self.sprids['cursors']['inv_select']:
                            self.sprids['cursors']['inv_select'][thg].unhide(self.persos[self.perso].aff_inv)
                else:
                    for thg in self.sprids['cursors']['inv_select']:
                        self.sprids['cursors']['inv_select'][thg].unhide(self.persos[self.perso].aff_inv)
                #self.graphic.unhide(self.sprids['hud']['inv_select'],self.persos[self.perso].aff_inv)

                self.persos[self.perso].toggle_inv()

        elif self.actions[self.action] == 'menu':

            if symbol == key.ESCAPE:
                if self.actions_menu[self.action_menu] == 'pause':
                    self.navigate('showing')
                elif self.actions_menu[self.action_menu] == 'main':
                    self.get_out()
                else:
                    self.navigate(False,'menu')

            if self.actions_menu[self.action_menu] == 'newmap' and self.specMan.to_draw['new_map_wrtgbar'].selected:

                if symbol in self.goodkeys:
                    result = ''
                    if self.keys[key.LSHIFT]:
                        result = self.goodkeys[symbol].upper()
                    else:
                        result = self.goodkeys[symbol].lower()
                    self.specMan.to_draw['new_map_wrtgbar'].add_letter(result)

                elif symbol == key.BACKSPACE:
                    self.specMan.to_draw['new_map_wrtgbar'].del_letter()
                elif symbol == key.RETURN:
                    self.specMan.to_draw['new_map_wrtgbar'].he_tried_to_validate_XO()

        elif self.actions[self.action] in ['loading','creating']:
            if symbol == key.ESCAPE:
                self.quit_land(False)

    def on_mouse_motion(self,x,y,dx,dy):

        self.clicks['M'] = [x,y]
        self.mouse_speed = module(dx,dy)
        #print(module(dx,dy))

        if self.actions[self.action] == 'menu':

            self.boxes_boutons = []
            for name in self.buttons[self.actions_menu[self.action_menu]]:
                if type(self.specMan.to_draw[name]) == drawable.LabelButton:
                    self.boxes_boutons.append(self.specMan.to_draw[name].get_box())
                else:
                    self.boxes_boutons.append([0,0,-10,-10])

            if self.keys[key.W]:
                print(self.boxes_boutons,(x,y))

            selected = tut.colli_ABP_mult(self.boxes_boutons,(x,y))
            if selected == None: #aucun boutton selectionné
                for name in self.buttons[self.actions_menu[self.action_menu]]:
                    if type(self.specMan.to_draw[name]) == drawable.LabelButton:
                        self.specMan.to_draw[name].the_mouse_is_not_here_anymore()
            else: #un bouton selected
                nameSel = self.buttons[self.actions_menu[self.action_menu]][selected]
                for name in self.buttons[self.actions_menu[self.action_menu]]:
                    if name == nameSel:
                        self.specMan.to_draw[name].the_mouse_is_here()
                    else:
                        if type(self.specMan.to_draw[name]) == drawable.LabelButton:
                            self.specMan.to_draw[name].the_mouse_is_not_here_anymore()

        elif self.actions[self.action] == 'showing' and self.in_land:


            if self.persos[self.perso].aff_inv and (tut.colli_ABP_XY(pup.BOX['hud_inventory'][0],(x,y)) or tut.colli_ABP_XY(pup.BOX['hud_inventory'][1],(x,y))):
                if self.selection != 'inventory':
                    self.selection = 'inventory'
                for thg in self.sprids['cursors']['select']:
                    self.sprids['cursors']['select'][thg].unhide(True)
            elif self.selection != 'normal':
                self.selection = 'normal'
                for thg in self.sprids['cursors']['inv_select']:
                    self.sprids['cursors']['inv_select'][thg].unhide(True)

            pos = tut.from_real_to_pxpos(tut.XY_Pos(x,y))
            if self.selection == 'normal':
                self.persos[self.perso].select(pos)
            elif self.selection == 'inventory':
                self.persos[self.perso].in_inv_select((x,y))

            oldskin = self.persos[self.perso].skin
            self.persos[self.perso].update_skin(pos)

            #print('bouging')

    def on_mouse_drag(self,x, y, dx, dy, buttons, modifiers):

        self.clicks['M'] = [x,y]
        if self.actions[self.action] == 'showing':


            if self.persos[self.perso].aff_inv and (tut.colli_ABP_XY(pup.BOX['hud_inventory'][0],(x,y)) or tut.colli_ABP_XY(pup.BOX['hud_inventory'][1],(x,y))):
                if self.selection != 'inventory':
                    self.selection = 'inventory'
                for thg in self.sprids['cursors']['select']:
                    self.sprids['cursors']['select'][thg].unhide(True)
                #self.graphic.unhide(self.sprids['cursors']['select'],True)
            elif self.selection != 'normal':
                self.selection = 'normal'
                for thg in self.sprids['cursors']['inv_select']:
                    self.sprids['cursors']['inv_select'][thg].unhide(True)
                #self.graphic.unhide(self.sprids['hud']['inv_select'],True)

            pos = tut.from_real_to_pxpos(tut.XY_Pos(x,y))
            if self.selection == 'normal':
                self.persos[self.perso].select(pos)
                self.selector_modify((x,y),None,True)
            elif self.selection == 'inventory':
                self.persos[self.perso].in_inv_select((x,y))

            oldskin = self.persos[self.perso].skin
            self.persos[self.perso].update_skin(pos)

        if buttons == pyglet.window.mouse.RIGHT :
            self.clicks['R'] = [x,y]
        elif buttons == pyglet.window.mouse.LEFT :
            self.clicks['L'] = [x,y]

    def on_mouse_press(self,x, y, button, modifiers):

        if button == pyglet.window.mouse.RIGHT :
            self.clicks['R'] = [x,y]
        elif button == pyglet.window.mouse.LEFT :
            self.clicks['L'] = [x,y]


        if self.actions[self.action] == 'menu':
            for name in self.buttons[self.actions_menu[self.action_menu]]:
                if type(self.specMan.to_draw[name]) == drawable.LabelButton:
                    if self.specMan.to_draw[name].here:
                        self.specMan.to_draw[name].i_am_pressed()
                elif type(self.specMan.to_draw[name]) == drawable.WritingBar:
                    if not (x>= self.specMan.to_draw[name].x - self.specMan.to_draw[name].box[0] and x<= self.specMan.to_draw[name].x + self.specMan.to_draw[name].box[0] and y>= self.specMan.to_draw[name].y - self.specMan.to_draw[name].box[1] and y<= self.specMan.to_draw[name].y + self.specMan.to_draw[name].box[1] ):
                        if self.specMan.to_draw[name].selected:
                            self.specMan.to_draw[name].he_tried_to_validate_XO()

        elif self.actions[self.action] == 'showing':
            if button == pyglet.window.mouse.LEFT and self.selection == 'inventory':
                self.persos[self.perso].in_inv_grab()

    def on_mouse_release(self,x, y, button, modifiers):

        if button == pyglet.window.mouse.RIGHT :
            self.clicks['R'] = False
        elif button == pyglet.window.mouse.LEFT :
            self.clicks['L'] = False

        if self.actions[self.action] == 'menu':
            for name in self.buttons[self.actions_menu[self.action_menu]]:
                if type(self.specMan.to_draw[name]) == drawable.LabelButton:
                    if self.specMan.to_draw[name].pressed == True:
                        #print(name,type(self.specMan.to_draw[name]),type(self.specMan.to_draw['new_map_wrtgbar']))
                        self.specMan.to_draw[name].i_am_released()

                        ## on reverifie si la souris est encore sur un btn après validation de l'autre
                        self.on_mouse_motion(*self.clicks['M'],0,0)


                elif type(self.specMan.to_draw[name]) == drawable.WritingBar:
                    #print(name,type(self.specMan.to_draw[name]),type(self.specMan.to_draw['new_map_wrtgbar']))
                    if x>= self.specMan.to_draw[name].x - self.specMan.to_draw[name].box[0] and x<= self.specMan.to_draw[name].x + \
                    self.specMan.to_draw[name].box[0] and y>= self.specMan.to_draw[name].y - self.specMan.to_draw[name].box[1] and y<= self.specMan.to_draw[name].y + self.specMan.to_draw[name].box[1]:
                        self.specMan.to_draw[name].i_am_selected()

        if self.actions[self.action] == 'showing':
            if button == pyglet.window.mouse.LEFT and self.selection == 'inventory':
                self.persos[self.perso].in_inv_drop()
            """
            if button == pyglet.window.mouse.RIGHT and self.selection == 'normal':
                self.cmd.add('verif_R',self.selector_modify((x,y),'R',val=0))
            elif button == pyglet.window.mouse.LEFT and self.selection == 'normal':
                self.cmd.add('verif_L',self.selector_modify((x,y),'L',val=0))
                #self.selector_modify((x,y),'L',val=0)"""

    def on_mouse_scroll(self,x, y, scroll_x, scroll_y):

        if type(scroll_y) != int:
            scroll_y = int(scroll_y)

        if self.actions[self.action] == 'showing':
            #self.cmd.add('scrolling',scroll_y)
            self.persos[self.perso].scroll_tool(-scroll_y)

    ### MY EVENTS (bcz pyglet is not very ouf)

    def on_my_resize(self):
        w,h = self.get_size()
        print('I\'ve been resized, my new size is',w,h)
        pup.set_size_screen((w,h))


    ### REFRESH FUNCTIONS

    def refresh_persos(self):

        t = time.time()

        for perso in self.persos:

            ## APPLYING BOT BEHAVIOUR
            if perso != self.perso:
                self.persos[perso].being_a_bot()

            ## ACTUALISE DATA OF PERSO
            self.persos[perso].actualise_general()

            if perso == self.perso:
                if self.persos[perso].dead:
                    self.graphic.unhide(self.sprids['game_over'])

                else:
                    self.graphic.unhide(self.sprids['game_over'],True)

            ## ACTUALISE POSITION OF PERSO

            #1st layer of position
            real_pos =  tut.from_pxpos_to_realpos(self.persos[perso].px_pos,False)

            if perso == self.perso:
                # updating camera
                tab = []
                if real_pos.x > 3*(self.current_size_scr[0]//4) or real_pos.x < self.current_size_scr[0]//4:
                    tab.append('x')
                if real_pos.y > 3*(self.current_size_scr[1]//4) or real_pos.y < self.current_size_scr[1]//4:
                    tab.append('y')
                if tab != []:
                    self.reset_camera(tab)

                # updating inventory selection
                if not 'invent_select' in self.sprids['cursors']:
                    self.sprids['cursors']['invent_select'] = graphic.Cursor('invent_select',self.graphic,self.textids['effects'],51,['hud'],2,self.persos[perso].invent_pxx[self.persos[perso].tool],vis=self.persos[perso].aff_inv)
                    #print('oklmmmm')
                else:
                    if [*self.sprids['cursors']['invent_select'].get_pos()] != self.persos[perso].invent_pxx[self.persos[perso].tool]:
                        self.sprids['cursors']['invent_select'].set_pos(self.persos[perso].invent_pxx[self.persos[perso].tool])
                    #print(self.graphic.sprites[self.sprids['cursors']['invent_select']].x , self.graphic.sprites[self.sprids['cursors']['invent_select']].y)

            #2nd and final layer of position
            real_pos = tut.xy_add(real_pos,self.admin_cam.pos,-1)

            if perso == self.perso:
                # updating cursor selection
                if self.selection == 'normal':

                    #self.graphic.unhide(self.sprids['hud']['inv_select'],True)
                    to_del = []
                    for (b,c) in self.sprids['cursors']['select']:
                        inthere = False
                        for box in self.persos[perso].selection:
                            biom,case,pos,lvl = box.pos()
                            if (biom,case) == (b,c):
                                inthere = True
                                break
                        if not inthere:
                            to_del.append((b,c))
                    for thg in to_del:
                        self.sprids['cursors']['select'][thg].delete()
                        del self.sprids['cursors']['select'][thg]

                    for box in self.persos[perso].selection:
                        b,c,p,l = box.pos()
                        #sprid = self.sprids['bioms'][b][l][c]
                        if not (b,c) in self.sprids['cursors']['select']:
                            #self.cmd.add('adding',box)
                            self.sprids['cursors']['select'][b,c] = graphic.Cursor('select_'+str(b)+'_'+str(c),self.graphic,self.textids['effects'],16,[None,None,l],1,tut.from_pxpos_to_realpos(tut.from_bcx_to_xy(box.Pos())).xy())

                            #self.graphic.addSpr(self.textids['effects'][16],tut.from_pxpos_to_realpos(tut.from_bcx_to_xy(box.Pos())).xy())
                            #self.graphic.addToGroup(self.sprids['cursors']['select'][b,c],[None,None,l],1)
                            #self.cmd.add('selectspr',self.graphic.sprites[self.sprids['cursors']['select'][(b,l,c)]])
                        else:
                            newp = tut.from_pxpos_to_realpos(tut.from_bcx_to_xy(box.Pos())).xy()
                            if self.sprids['cursors']['select'][b,c].get_pos() != newp:
                                self.sprids['cursors']['select'][b,c].set_pos(newp)

                elif self.selection == 'inventory':

                    #self.graphic.unhide(self.sprids['cursors']['select'],True)
                    to_del = []
                    for thg in self.sprids['cursors']['inv_select']:
                        inthere = False
                        for thg2 in self.persos[self.perso].inv_selection:
                            if thg == thg2:
                                inthere = True
                                break
                        if not inthere:
                            to_del.append(thg)
                    for thg in to_del:
                        self.sprids['cursors']['inv_select'][thg].delete()
                        del self.sprids['cursors']['inv_select'][thg]

                    for thg in self.persos[perso].inv_selection:

                        if not thg in self.sprids['cursors']['inv_select']:
                            #self.cmd.add('adding',box)
                            self.sprids['cursors']['inv_select'][thg] = graphic.Cursor('inv_select'+str(thg),self.graphic,self.textids['effects'],49,['hud'],2,self.persos[perso].invent_pxx[thg])

                                #self.graphic.addSpr(self.textids['effects'][32],self.persos[perso].invent_pxx[thg])
                                #self.graphic.addToGroup(self.sprids['hud']['inv_select'][thg],['hud'],2)


            ## ACTUALISE INVENTORY AND UPDATE TERRAIN WITH/WITHOUT CASES BROKEN
            if perso == self.perso:
                #selection
                pos = tut.from_real_to_pxpos(tut.XY_Pos(*self.clicks['M']))
                self.persos[self.perso].select(pos)

            if type(self.persos[perso]) == pso.Perso:
                # update list of cases that perso has broken
                for case in self.persos[perso].updatelist:
                    i,j,x,y = case.ijxy()
                    key = self.terrain.get_case(case)
                    if key != 0:
                        self.sprids['bioms'][i,j][case.l][x,y] = self.graphic.addSpr(self.textids['ground'][key],tut.from_bcx_to_pxx((i,j),(x,y)))
                        self.graphic.addToGroup(self.sprids['bioms'][i,j][case.l][x,y],[None,None,case.l])
                    else:
                        if self.sprids['bioms'][i,j][case.l][x,y] != 0:
                            self.graphic.delete(self.sprids['bioms'][i,j][case.l][x,y])
                            self.sprids['bioms'][i,j][case.l][x,y] = 0

                self.persos[perso].updatelist = []


            # creating persos sprites and nametags if it's not done and updating positions if already created
            if not perso in self.sprids['persos']:

                #REAL PERSO
                self.sprids['persos'][perso] = self.graphic.addSpr(self.textids['persos'][self.persos[perso].skin],real_pos.xy())
                self.graphic.addToGroup(self.sprids['persos'][perso],[None,None,self.persos[perso].pos.lvl()])

                self.sprids['persosplus']['actual'] = []
                self.sprids['persosplus']['near'] = []

                #ACTUAL CASES
                for case in self.persos[perso].px_actual_cases:

                    real_pos_plus =  tut.from_pxpos_to_realpos(case,False)
                    real_pos_plus = tut.xy_add(real_pos_plus,self.admin_cam.pos,-1)
                    self.sprids['persosplus']['actual'].append(self.graphic.addSpr(self.textids['persos'][self.persos[perso].plusposskin[0]],real_pos_plus.xy(),vis=False))
                    self.graphic.addToGroup(self.sprids['persosplus']['actual'][-1],['front'],-1)

                #NEAR CASES
                for case in self.persos[perso].px_near_cases:

                    real_pos_plus =  tut.from_pxpos_to_realpos(case,False)
                    real_pos_plus = tut.xy_add(real_pos_plus,self.admin_cam.pos,-1)
                    self.sprids['persosplus']['near'].append(self.graphic.addSpr(self.textids['persos'][self.persos[perso].plusposskin[1]],real_pos_plus.xy(),vis=False))
                    self.graphic.addToGroup(self.sprids['persosplus']['near'][-1],['front'],-1)

                #NAMETAG

                pos = [*real_pos.xy()]
                pos[0] += (tut.SIZE_TILE[0]/2)*pup.GEN['1x']
                pos[1] += tut.SIZE_TILE[1]*pup.GEN['1y']
                self.lblids['hud']['nametags'][perso] = self.labman.addLabel(self.persos[perso].name,pos,vis=not self.aff_hud,font_size=10*pup.GEN['1y'],font_name='arial',anchor=('center','bottom'))
                self.labman.addToGroup(self.lblids['hud']['nametags'][perso],['hud'])

            else:

                #UPDATE SKIN
                self.graphic.set_text(self.sprids['persos'][perso],self.textids['persos'][self.persos[perso].skin])

                #REAL PERSO
                self.graphic.modify(self.sprids['persos'][perso],real_pos.xy(),group=[[None,None,self.persos[perso].pos.lvl()]])

                #ACTUAL CASES
                for i in range(len(self.persos[perso].px_actual_cases)):
                    real_pos_plus =  tut.from_pxpos_to_realpos(self.persos[perso].px_actual_cases[i],False)
                    real_pos_plus = tut.xy_add(real_pos_plus,self.admin_cam.pos,-1)
                    self.graphic.modify(self.sprids['persosplus']['actual'][i],real_pos_plus.xy())

                #NEAR CASES
                for i in range(len(self.persos[perso].px_near_cases)):
                    real_pos_plus =  tut.from_pxpos_to_realpos(self.persos[perso].px_near_cases[i],False)
                    real_pos_plus = tut.xy_add(real_pos_plus,self.admin_cam.pos,-1)
                    self.graphic.modify(self.sprids['persosplus']['near'][i],real_pos_plus.xy())

                #NAMETAG
                self.labman.set_text(self.lblids['hud']['nametags'][perso],self.persos[perso].name)
                pos = [*real_pos.xy()]
                pos[0] += (tut.SIZE_TILE[0]/2)*pup.GEN['1x']
                pos[1] += tut.SIZE_TILE[1]*pup.GEN['1y']
                self.labman.modify(self.lblids['hud']['nametags'][perso],pos)

            ## ACTUALISE HUD
            if perso == self.perso:
                self.actualise_hud()

        return time.time()-t

    ### LOOP FUNCTIONS

    def events(self):

        if self.actions[self.action] == 'showing' or self.actions[self.action] == 'showing2':

            if self.keys[key.O]:

                biom = self.persos[self.perso].pos.x[0],self.persos[self.perso].pos.y[0]
                self.reset_biom(biom)

            moved = False
            if self.keys[key.Z]:
                self.persos[self.perso].move([0,1],self.keys[key.LSHIFT],self.keys[key.SPACE])
                moved = True
            if self.keys[key.S]:
                self.persos[self.perso].move([0,-1],self.keys[key.LSHIFT],self.keys[key.SPACE])
                moved = True
            if self.keys[key.Q]:
                self.persos[self.perso].move([-1,0],self.keys[key.LSHIFT],self.keys[key.SPACE])
                moved = True
            if self.keys[key.D]:
                self.persos[self.perso].move([1,0],self.keys[key.LSHIFT],self.keys[key.SPACE])
                moved = True

            #if moved:
            #    self.graphic.set_text(self.sprids['persos'][self.perso],self.textids['persos'][self.persos[self.perso].skin])

            if self.keys[key.M]:
                print(' ',self.terrain.terrains['ground'][self.persos[self.perso].pos.y[1]-1][self.persos[self.perso].pos.x[1]])
                print(self.terrain.terrains['ground'][self.persos[self.perso].pos.y[1]][self.persos[self.perso].pos.x[1]-1],self.terrain.terrains['ground'][self.persos[self.perso].pos.y[1]][self.persos[self.perso].pos.x[1]],self.terrain.terrains['ground'][self.persos[self.perso].pos.y[1]][self.persos[self.perso].pos.x[1]+1])
                print(' ',self.terrain.terrains['ground'][self.persos[self.perso].pos.y[1]+1][self.persos[self.perso].pos.x[1]])
                print('')

            if self.clicks['L'] != False and self.selection == 'normal':
                self.selector_modify(self.clicks['L'],'L')
            if self.clicks['R'] != False and self.selection == 'normal':
                self.selector_modify(self.clicks['R'],'R')

            if self.security == 'admin':

                reset_cam = True
                if self.keys[key.UP]:
                    self.admin_cam.move(tut.XY_Vec(0,-60))
                    #self.admin_cam[1]-=60
                    reset_cam = False
                if self.keys[key.DOWN]:
                    self.admin_cam.move(tut.XY_Vec(0,60))
                    #self.admin_cam[1]+=60
                    reset_cam = False
                if self.keys[key.RIGHT]:
                    self.admin_cam.move(tut.XY_Vec(-60,0))
                    #self.admin_cam[0]-=60
                    reset_cam = False
                if self.keys[key.LEFT]:
                    self.admin_cam.move(tut.XY_Vec(60,0))
                    #self.admin_cam[0]+=60
                    reset_cam = False

                if reset_cam:
                    #self.admin_cam = [0,0]
                    self.admin_cam.pos = tut.XY_Vec()

        """elif self.actions[self.action] in ['loading','creating']:
            if self.keys[key.ESCAPE]:
                self.quit_land(False)"""

    def refresh(self):

        #time1,time2,time3,time4 = 0,0,0,0
        t = {}

        if self.actions[self.action] == 'showing' or self.actions[self.action] == 'showing2':

            elapsed_time = time.time()

            ### CAMERA'S CONTROL
            self.camera.update()

            ### MOUSE
            self.mouse_speed = self.mouse_speed/15
            if self.mouse_speed < 0.2:
                self.mouse_speed = 0

            t['TCamMouse'] = time.time()-elapsed_time

            ### REFRESH PERSOS
            t['TPerso'] = self.refresh_persos()


            ### REFRESH MAP
            titime = time.time()
            if not 'map_crsr' in self.sprids['cursors']:
                self.sprids['cursors']['map_crsr'] = graphic.Cursor('map_crsr',self.graphic,self.textids['effects'],51,['map'],1,tut.get_pos_map_biom(self.persos[self.perso].get_biom(),self.current_size_scr))
                self.sprids['cursors']['map_crsr'].set_ani([64]*100+[i for i in range(64,73)]+[72]*100+[i for i in range(72,63,-1)])
                self.sprids['cursors']['map_crsr'].set_text(50)
            else:
                if self.sprids['cursors']['map_crsr'].is_visible():
                    self.sprids['cursors']['map_crsr'].up_skin()
                    self.sprids['cursors']['map_crsr'].set_pos(tut.get_pos_map_biom(self.persos[self.perso].get_biom(),self.current_size_scr))

            if self.aff_map[0] and not self.aff_map[1] :
                self.aff_map[1] = 1
                self.effectMan.unhide('blur50_map')
                self.sprids['cursors']['map_crsr'].unhide()
                self.graphic.unhide(self.sprids['map'])
                #for (i,j) in self.sprids['map']:
                #    self.graphic.sprites[self.sprids['map'][i,j]].visible = True

            elif self.aff_map[1] and not self.aff_map[0]:
                self.aff_map[1] = 0
                self.effectMan.unhide('blur50_map',True)
                self.sprids['cursors']['map_crsr'].unhide(True)
                self.graphic.unhide(self.sprids['map'],True)
                #for (i,j) in self.sprids['map']:
                #    self.graphic.sprites[self.sprids['map'][i,j]].visible = False

            t['TMap'] = time.time()-titime

            ### REFRESH TERRAIN
            big_time = time.time()

            self.cmd.add("nb_spr_to_draw",self.nb_spr_to_draw)
            first_spr = []

            if self.actions[self.action] == 'showing3':
                """VIEUUUUUX CA MAAAARCHE PAAAAS"""

                #self.old_spr_to_print = self.spr_to_print
                #self.spr_to_print = []

                ## listage de tous les sprites présents sur l'écran : donc à afficher
                time1 = time.time()
                #print(x_on_scr,y_on_scr)
                first_spr_x = self.persos[self.perso].pos.x[1] - ((x_on_scr - self.persos[self.perso].pos.x[2])//tut.SIZE_TILE[0] +1)
                first_spr_y = self.persos[self.perso].pos.y[1] - ((y_on_scr - self.persos[self.perso].pos.y[2])//tut.SIZE_TILE[0] +1)

                biomi = self.persos[self.perso].pos.x[0] + first_spr_x//tut.SIZE_BIOM[0],self.persos[self.perso].pos.y[0] + first_spr_y//tut.SIZE_BIOM[1]
                casei = first_spr_x - (first_spr_x//tut.SIZE_BIOM[0])*tut.SIZE_BIOM[0],first_spr_y - (first_spr_y//tut.SIZE_BIOM[1])*tut.SIZE_BIOM[1]
                posi = -self.persos[self.perso].pos.x[2] , self.current_size_scr[1]+self.persos[self.perso].pos.y[2]
                #print(biomi,casei,posi)
                biomf,casef = [],[]

                diff = [biomi[0] - self.old_spr_limit[0][0],biomi[1] - self.old_spr_limit[0][1],casei[0] - self.old_spr_limit[0][2],casei[1] - self.old_spr_limit[0][3]]

                ii,jj = 0,0

                time1 = time.time() - time1


                # on parcourt maitenant tous les sprites depuis le premier à afficher jusqu'au premier + la longueur de la liste à afficher
                for k in range(self.nb_spr_to_draw_y):
                    ii=0
                    for p in range(self.nb_spr_to_draw_x):

                        elapsed_time = time.time()
                        x,y = casei[0] + p - ii*tut.SIZE_BIOM[0] , casei[1] + k - jj*tut.SIZE_BIOM[1]
                        if x == tut.SIZE_BIOM[0]:
                            ii += 1
                            x = 0
                        if y == tut.SIZE_BIOM[1]:
                            jj += 1
                            y = 0

                        i,j = biomi[0] + ii , biomi[1] + jj


                        posx,posy = posi[0]+ p*tut.SIZE_TILE[0] , posi[1] - k*tut.SIZE_TILE[0]

                        time2 += time.time() - elapsed_time

                        try :
                            elapsed_time = time.time()
                            self.graphic.sprites[self.sprids['bioms'][i,j][x,y]].x = posx
                            self.graphic.sprites[self.sprids['bioms'][i,j][x,y]].y = posy

                            to_print = False

                            if diff[0] > 0 and i > self.old_spr_limit[1][0]:
                                to_print = True
                            elif diff[0] == 0 and x > self.old_spr_limit[1][2]:
                                to_print = True


                            elif diff[0] < 0 and i < self.old_spr_limit[0][0]:
                                to_print = True
                            elif diff[0] == 0 and x < self.old_spr_limit[0][2]:
                                to_print = True


                            elif diff[1] > 0 and j > self.old_spr_limit[1][1]:
                                to_print = True
                            elif diff[1] == 0 and y > self.old_spr_limit[1][3]:
                                to_print = True

                            elif diff[1] < 0 and j < self.old_spr_limit[0][1]:
                                to_print = True
                            elif diff[1] == 0 and y < self.old_spr_limit[0][3]:
                                to_print = True


                            if to_print:
                                self.graphic.sprites[self.sprids['bioms'][i,j][x,y]].visible = True


                            time3 += time.time() - elapsed_time

                        except :
                            a=0
                            #print(first_spr_x,first_spr_y, '    ' ,k,p,'     ',i,j,'     ',x,y)

                            print('x:',x,'\n',
                                    'casei:',casei,'\n',
                                    'p:',p,'\n',
                                    'ii:',ii,'\n',
                                    'tut.SIZE_BIOM[0]:',tut.SIZE_BIOM[0],'\n',
                                    )

                            print(self.nb_spr_to_draw_x , "=" ,self.current_size_scr[0],"//",tut.SIZE_TILE[0] , "+ 1\n",
                                        #print(x_on_scr,y_on_scr)
                                        first_spr_x , "=" ,self.persos[self.perso].pos.x[1] , "-" ,"((",x_on_scr , "-" ,self.persos[self.perso].pos.x[2],")","//",tut.SIZE_TILE[0] , "+1",")\n",

                                        biomi , "=" ,self.persos[self.perso].pos.x[0] , "+" ,first_spr_x,"//",tut.SIZE_BIOM[0],"\n",
                                        casei , "=" ,first_spr_x , "-" ,"(",first_spr_x,"//",tut.SIZE_BIOM[0],")","*",tut.SIZE_BIOM[0],"\n",
                                        posi , "= -" ,self.persos[self.perso].pos.x[2],"\n",

                                        "p,k =",k,p,
                                        "x,y =",x,y,
                                        "i,j =",i,j

                                        )

                            print(self.nb_spr_to_draw_x , "=" ,self.current_size_scr[0],"//",tut.SIZE_TILE[0] , "+ 1\n",
                                        self.nb_spr_to_draw_y , "=" ,self.current_size_scr[1],"//",tut.SIZE_TILE[0] , "+1\n",
                                        #print(x_on_scr,y_on_scr)
                                        first_spr_x , "=" ,self.persos[self.perso].pos.x[1] , "-" ,"((",x_on_scr , "-" ,self.persos[self.perso].pos.x[2],")","//",tut.SIZE_TILE[0] , "+1",")\n",
                                        first_spr_y , "=" ,self.persos[self.perso].pos.y[1] , "-" ,"((",y_on_scr , "-" ,self.persos[self.perso].pos.y[2],")","//",tut.SIZE_TILE[0] , "+1",")\n",

                                        biomi , "=" ,self.persos[self.perso].pos.x[0] , "+" ,first_spr_x,"//",tut.SIZE_BIOM[0],",",self.persos[self.perso].pos.y[0] , "+" ,first_spr_y,"//",tut.SIZE_BIOM[1],"\n",
                                        casei , "=" ,first_spr_x , "-" ,"(",first_spr_x,"//",tut.SIZE_BIOM[0],")","*",tut.SIZE_BIOM[0],",",first_spr_y , "-" ,"(",first_spr_x,"//",tut.SIZE_BIOM[1],")","*",tut.SIZE_BIOM[1],"\n",
                                        posi , "= -" ,self.persos[self.perso].pos.x[2] , ", -" ,self.persos[self.perso].pos.y[2],"\n",

                                        "p,k =",k,p,
                                        "x,y =",x,y,
                                        "i,j =",i,j

                                        )

                            #self.playing = False
                            #break

                        if k == self.nb_spr_to_draw_y-1 and p == self.nb_spr_to_draw_x-1:
                            print('jtebez')
                            biomf =[i,j]
                            casef = [x,y]

                for [i,j,x,y] in self.old_spr_to_print:
                    self.graphic.sprites[self.sprids['bioms'][i,j][x,y]].visible = False


                #   Pas fini bordel
                #   c'est relou pcq faut encore selectionner les sprites qui ont été affichés au tour d'avant mais qui ne sont plus sur l'écran
                #   et donc qu'on doit rendre invisible sinon ça part en couille...
                #   Seulement le truc c'est que ya bcp trop de possibilités à traiter et j'ai la flemme surtout que je suis pas convaincu du rendement
                #   niveau fps... donc booooh pour le moment go utiliser 'showing' au lieu de 'showing2' hein ?

                if diff[0] == 0 and diff[1] == 0:  ### ATTENTION ON IMPLEMENTE PAS LE CAS OU ON CHANGERAIT COMPLETEMENT DE BIOME INSTANT'
                    if diff[2] > 0 :
                        for x in range(self.old_spr_limit[0][2],casei[0]):
                            if diff[3] > 0:
                                for y in range(self.old_spr_limit[0][3],biomi[1]):
                                    self.graphic.sprites[self.sprids['bioms'][biomi][x,y]].visible = False
                            else:
                                for y in range(casef[1],self.old_spr_limit[1][3]):
                                    self.graphic.sprites[self.sprids['bioms'][biomi][x,y]].visible = False
                    else:
                        for x in range(casef[0],self.old_spr_limit[1][2]):
                            if diff[3] > 0:
                                for y in range(self.old_spr_limit[0][3],biomi[1]):
                                    self.graphic.sprites[self.sprids['bioms'][biomi][x,y]].visible = False
                            else:
                                for y in range(casef[1],self.old_spr_limit[1][3]):
                                    self.graphic.sprites[self.sprids['bioms'][biomi][x,y]].visible = False



                self.old_spr_limit = [  [biomi[0],biomi[1],casei[0],casei[1]] , [biomf[0],biomf[1],casef[0],casef[1]]  ]

                """elif self.actions[self.action] == 'showing2':


                a=0"""

            else:


                self.old_bioms_to_print = self.bioms_to_print
                #self.old_bioms_to_print = mycopy(self.bioms_to_print)
                self.bioms_to_print = []

                for i in range(self.persos[self.perso].pos.x[0]-1,self.persos[self.perso].pos.x[0]+2):
                    for j in range(self.persos[self.perso].pos.y[0]-1,self.persos[self.perso].pos.y[0]+2):
                        if i >= 0 and j >= 0 and i < tut.SIZE_TERRAIN[0] and j < tut.SIZE_TERRAIN[1]:
                            self.bioms_to_print.append((i,j))
                #print(bioms_to_print)

                nb_spr_on_scr = 0
                first_spr , last_spr = [],[]

                t['TN']=0# , t['TL1'] ,t['TL2'] = 0,0,0

                for (i,j) in self.bioms_to_print:

                    elapsed_time = time.time()
                    for lvl in range(len(self.terrain.Bioms[j][i].ground)):
                        for y in range(len(self.terrain.Bioms[j][i].ground[lvl])):
                            for x in range(len(self.terrain.Bioms[j][i].ground[lvl][y])):
                                if self.terrain.Bioms[j][i].ground[lvl][y][x] != 0:

                                    #little_time = time.time()
                                    posx,posy = tut.from_bcx_to_pxx((i,j),(x,y))
                                    #posx,posy = tut.from_pxpos_to_realpos(tut.from_bcx_to_xy( tut.BCX_Pos((i,j),(x,y)) )).xy()

                                    #t['TL1']+=time.time()-little_time
                                    #little_time = time.time()

                                    if posx > -tut.SIZE_TILE[0] and posx < self.current_size_scr[0]+tut.SIZE_TILE[0] and posy > -tut.SIZE_TILE[0] and posy < self.current_size_scr[1]+tut.SIZE_TILE[0]:

                                        """nb_spr_on_scr+=1
                                        if first_spr != []:
                                            if first_spr[0] >= posx and first_spr[1] >= posy:
                                                first_spr = [posx,posy]
                                        else:
                                            first_spr = [posx,posy]

                                        if last_spr != []:
                                            if last_spr[0] <= posx and last_spr[1] <= posy:
                                                last_spr = [posx,posy]
                                        else:
                                            last_spr = [posx,posy]"""

                                        if not self.graphic.sprites[self.sprids['bioms'][i,j][lvl][x,y]].visible:
                                            self.graphic.sprites[self.sprids['bioms'][i,j][lvl][x,y]].visible = True
                                        self.graphic.sprites[self.sprids['bioms'][i,j][lvl][x,y]].position = posx,posy
                                    elif self.graphic.sprites[self.sprids['bioms'][i,j][lvl][x,y]].visible:
                                        self.graphic.sprites[self.sprids['bioms'][i,j][lvl][x,y]].visible = False

                                    #t['TL2']+=time.time()-little_time

                    #self.verif((i,j))

                    t['TN']+=time.time()-elapsed_time

                for (i,j) in self.old_bioms_to_print:
                    elapsed_time = time.time()
                    if (i,j) not in self.bioms_to_print:
                        #print(i,j)
                        #print(self.sprids['bioms'][i,j])
                        for lvl in self.sprids['bioms'][i,j]:
                            for cas in self.sprids['bioms'][i,j][lvl]:
                                if self.sprids['bioms'][i,j][lvl][cas] != 0:
                                    if self.graphic.sprites[self.sprids['bioms'][i,j][lvl][cas]].visible:
                                        self.graphic.sprites[self.sprids['bioms'][i,j][lvl][cas]].visible = False

                    #self.verif((i,j))

                self.cmd.add('    ','')
                self.cmd.add('sprites on screen :','')
                self.cmd.add('   count',nb_spr_on_scr)
                self.cmd.add('   first',first_spr )
                self.cmd.add('   last',last_spr)

            t['TTerrain'] = time.time()-big_time

        elif self.actions[self.action]  == 'creating':

            local_time = time.time()

            load = self.creating

            state = load['state']

            go_on = False
            add_per = False

            # all the differents states
            if state == 0: #'initialisating creation'
                #print(SIZE_BIOM)

                #size_terrain = SIZE_TERRAIN
                if self.loading['size'] != None:
                    size_terrain = self.loading['size']
                else:
                    size_terrain = self.text_size_land_menu_val[self.text_size_land_menu_sel]

                tut.set_var(size_terrain,SIZE_BIOM,(SIZE_TILE,SIZE_TILE))

                go_on = True
                add_per = True

            elif state == 1: #choosing zones

                load['w'],load['h'] = tut.SIZE_TERRAIN[0]*tut.SIZE_BIOM[0],tut.SIZE_TERRAIN[1]*tut.SIZE_BIOM[1]

                load['tab_map'] , load['tab_land'] = [],[]

                load['nb_zones'] = ((load['w']*load['h'])//8000)+1

                go_on = True
                add_per = True

            elif state == 2: #choosing grounds

                load['terrain'] = [ [ [0 for k in range(load['w'])] for q in range(load['h']) ] for _ in range(tut.DEPTH_BIOM) ]

                load['grounds'] = []

                if len(ALL_GROUNDS) > load['nb_zones']:

                    grounds = randmultint(load['nb_zones'],len(ALL_GROUNDS))

                    for k in grounds:
                        load['grounds'].append(ALL_GROUNDS[k])
                else:
                    load['grounds'] = ALL_GROUNDS

                go_on = True
                add_per = True

            elif state == 3: #creating noise

                load['terrain'][0] = get_diff_noised_list(load['w'],load['h'],1,style=2)

                go_on = True
                add_per = True

                #self.loadbar['nb_ope'] = self.loadbar['nb_ope'] -1 + len(load['terrain'][0][0])*len(load['terrain'][0])

            elif state == 4: #coloring terrain

                v=0
                for j in range(len(load['terrain'][0])):
                    for i in range(len(load['terrain'][0][j])):
                        if load['terrain'][0][j][i] == -1:
                            #print('lets go pour la',w+1,'e fois','key=',grounds[v])
                            color(load['terrain'][0],(i,j),load['grounds'][v])
                            v+=1
                            if v >= len(load['grounds']):
                                v=0
                        elif load['terrain'][0][j][i] == 0:
                            load['terrain'][0][j][i] = 2

                go_on = True
                self.loadbar['nb_ope'] = self.loadbar['nb_ope'] -1 + len(ASSETS)
                load['coloring_asset'] = 0
                self.loadbar['plus'] = ' '+ASSETS[load['coloring_asset']]

            elif state == 5: #placing assets

                load['terrain'][1] = createZone(load['terrain'][1],ASSETS[load['coloring_asset']],load['w'],load['h'])

                load['coloring_asset']+=1
                if load['coloring_asset'] >= len(ASSETS):
                    go_on = True
                add_per = True

                if go_on:
                    self.loadbar['plus'] = ''
                else:
                    self.loadbar['plus'] = ' '+ASSETS[load['coloring_asset']]

            elif state == 6: #verifing terrain

                load['terrain'] = verify(load['terrain'])

                go_on = True
                add_per = True

            elif state == 7: #splitting terrain

                load['tab_map'] , load['tab_land'] = from_ter_to_bioms(load['terrain'],tut.SIZE_TERRAIN,tut.SIZE_BIOM,tut.DEPTH_BIOM)

                go_on = True
                add_per = True

            elif state == 8: #creating persos

                # CREATION PERSOS
                load['tab_perso'] = []
                dic = {}
                dic['name'] = None
                dic['life'] = None
                dic['pos'] = [tut.SIZE_TERRAIN[0]//2,tut.SIZE_TERRAIN[1]//2,1,1,0,0,1]
                dic['type'] = 'Perso'
                dic['specie'] = 'human'
                dic['skin_dic'] = None
                dic['inventory'] = {}
                dic['main'] = True
                dic['id'] = get_id('perso')

                load['tab_perso'].append(dic)

                #load['nb_bots_to_create'] = 10

                go_on = True
                add_per = True


                load['nb_bots_per_row'] = 1000
                load['nb_row_bots_to_go'] = NB_BOTS_CREATE//load['nb_bots_per_row'] +1

                self.loadbar['nb_ope'] = self.loadbar['nb_ope'] -1 + load['nb_row_bots_to_go']

            elif state == 9: #creating bots

                if not 'row_bot_creating' in load:
                    load['row_bot_creating'] = 0

                nb_bot_row = load['nb_bots_per_row']

                if NB_BOTS_CREATE - load['row_bot_creating']*load['nb_bots_per_row'] < load['nb_bots_per_row']:
                    nb_bot_row = NB_BOTS_CREATE - load['row_bot_creating']*load['nb_bots_per_row']

                for i in range(nb_bot_row):

                    dic = {}
                    dic['name'] = None
                    dic['life'] = None
                    #pos = random.randint(0,tut.SIZE_BIOM[0]),random.randint(0,tut.SIZE_BIOM[1])
                    #dic['pos'] = [tut.SIZE_TERRAIN[0]//2,tut.SIZE_TERRAIN[1]//2,*pos,0,0,1]
                    dic['pos'] = None
                    dic['type'] = 'Living'
                    dic['specie'] = 'loutre'
                    dic['skin_dic'] = None
                    dic['main'] = False
                    dic['id'] = get_id('perso')

                    load['tab_perso'].append(dic)

                load['row_bot_creating']+=1
                if load['row_bot_creating'] >= load['nb_row_bots_to_go']:
                    go_on =True
                add_per = True

            elif state == 10: #finishing creating
                self.loading['tab_perso'],self.loading['tab_map'],self.loading['tab_land'] = \
                            load['tab_perso'],load['tab_map'],load['tab_land']
                self.navigate('loading')
                self.created = True

                go_on = True
                add_per = True

            # upgrading state
            if add_per:
                add = (100 - self.loadbar['percent'])/self.loadbar['nb_ope']
                self.loadbar['percent'] += add
                self.loadbar['nb_ope'] -= 1

            self.all_times[self.create_to_do[load['state']]] += time.time()-local_time

            # upgrading state
            if go_on:
                self.creating['state']+= 1
                if self.creating['state'] >= len(self.create_to_do):
                    del self.creating
                    del self.create_to_do

                    #if 'creating' in self.sprids:
            if hasattr(self, 'creating'):
                ## refresh loading bar + label
                size_fill = pup.SIZ['loading_bar'][0]*self.loadbar['percent']/100
                self.labman.set_text(self.lblids['loading'],self.create_to_do[load['state']]+self.loadbar['plus'])
                self.graphic.modify(self.sprids['loading']['fill'],scale=(size_fill/SIZE_TILE,1))
            else:
                ## refresh loading bar + label
                size_fill = pup.SIZ['loading_bar'][0]*self.loadbar['percent']/100
                self.labman.set_text(self.lblids['loading'],self.load_to_do[self.loading['state']]+self.loadbar['plus'])
                self.graphic.modify(self.sprids['loading']['fill'],scale=(size_fill/SIZE_TILE,1))

        elif self.actions[self.action]  == 'loading':

            local_time = time.time()

            load = self.loading

            state = load['state']

            go_on = False
            add_per = False

            # all the differents states
            if state == 0: ## 'extracting data from files'

                load['tab_perso'],load['tab_map'],load['tab_land'],load['name'] = self.load_land(load['name'])
                go_on = True
                add_per = True

            elif state == 1: ## 'initialisation of loading'


                ## mise en forme sizes
                size_terrain = len(load['tab_map'][0]) , len(load['tab_map'])
                size_biom = len(load['tab_land'][0][0][0][0]) , len(load['tab_land'][0][0][0])
                tut.set_var(size_terrain,size_biom)

                self.loadbar['nb_ope'] = self.loadbar['nb_ope'] -1 + tut.SIZE_TERRAIN[0]*tut.SIZE_TERRAIN[1]

                ## creation du terrain et mise dedans des bons bioms
                self.terrain = terrain.TerManager(tut.SIZE_TERRAIN,tut.SIZE_BIOM,load['name'])

                self.terrain.Bioms,self.terrain.map = [],[]
                for rangey in load['tab_land']:
                    y_for_real = []
                    for biom in rangey:
                        new_biom = terrain.emptyBiom(tut.SIZE_BIOM)
                        for lvl in range(len(biom)):
                            new_biom.set_ground(lvl,biom[lvl])
                        y_for_real.append(new_biom)
                    self.terrain.Bioms.append(y_for_real)
                self.terrain.map = load['tab_map']

                go_on = True
                add_per = True

            elif state == 2: ## initialisating sprites and labels'

                ## gestion des sprites
                self.sprids['persos'] = {}
                self.sprids['persosplus'] = {}
                self.sprids['bioms'] = {}
                self.sprids['map'] = {}
                self.sprids['hud'] = {}
                self.sprids['cursors'] = {}
                self.sprids['cursors']['select'] = {}
                self.sprids['cursors']['inv_select'] = {}

                for i in range(tut.SIZE_TERRAIN[0]):
                    for j in range(tut.SIZE_TERRAIN[1]):
                        self.sprids['bioms'][i,j] = {}
                        for lvl in range(tut.DEPTH_BIOM):
                            self.sprids['bioms'][i,j][lvl] = {}
                            for x in range(tut.SIZE_BIOM[0]):
                                for y in range(tut.SIZE_BIOM[1]):
                                    self.sprids['bioms'][i,j][lvl][x,y] = 0

                        self.sprids['map'][i,j] = 0

                self.aff_map = load['aff_map']

                ## gestion des labels
                self.lblids['hud'] = {}

                go_on = True
                add_per = True

            elif state == 3: ## 'loading persos'

                # GENEARTION PERSOS
                self.persos = {}

                for dic in load['tab_perso']:

                    if dic['pos'] != None:
                        init_pos = tut.BCX_Pos([dic['pos'][0],dic['pos'][1]],[dic['pos'][2],dic['pos'][3]],[dic['pos'][4],dic['pos'][5]],dic['pos'][6])
                        persobox = tut.BCX_Box(*init_pos.bcx(),init_pos.lvl(),c2=[1,1])
                    else:
                        persobox = None

                    if dic['main']:

                        self.perso = dic['id']

                    if dic['type'] == 'Perso':

                        self.persos[dic['id']] = pso.Perso(self.textids['ground'],self.textids['number'],self.graphic, self.terrain \
                                                            ,self.cmd,persobox,specie=dic['specie'],name=dic['name'],skin_seq=dic['skin_dic'])

                        self.selector = [0,[0,0],0]
                        self.persos[self.perso].set_inv(dic['inventory'])

                    elif dic['type'] == 'Living':

                        self.persos[dic['id']] = pso.LivingBot( self.terrain,self.cmd,persobox,specie=dic['specie'],name=dic['name'],skin_seq=dic['skin_dic'])

                    if dic['life'] != None:
                        self.persos[dic['id']].life,self.persos[dic['id']].max_life = dic['life']

                go_on = True
                add_per = True

            elif state == 4: ## 'initialisating hud elements'

                self.aff_hud = False

                self.init_hud()
                self.lblids['hud']['nametags'] = {}


                go_on = True
                add_per = True

            elif state == 5: ## 'initialisating camera'

                # INIT CAMERA

                posx,posy = self.current_size_scr[0]//2,self.current_size_scr[1]//2

                self.camera , self.admin_cam = tut.get_cam(tut.XY_Vec(posx,posy),8)
                tut.set_cam(self.camera , self.admin_cam)

                go_on = True
                add_per = True

            elif state == 6: ## 'creating sprites'

                posx_dep_map = self.current_size_scr[0]//2 - (tut.SIZE_TERRAIN[0]*tut.SIZE_TILE[0])//2
                posy_dep_map = self.current_size_scr[1]//2 + (tut.SIZE_TERRAIN[1]*tut.SIZE_TILE[0])//2


                # CREATION SPRITES DU TERRAIN + MAP
                self.old_spr_to_print = []
                self.old_spr_limit = []
                self.bioms_to_print = []

                if not 'loading_biom' in load:
                    load['loading_biom'] = [0,0]

                i,j = load['loading_biom']
                self.create_biom_sprites((i,j))

                posx2 = posx_dep_map + i*tut.SIZE_TILE[0]
                posy2 = posy_dep_map - (j+1)*tut.SIZE_TILE[0]
                self.sprids['map'][i,j] = self.graphic.addSpr(self.textids['ground'][self.terrain.map[j][i]],(posx2,posy2))
                self.graphic.addToGroup(self.sprids['map'][i,j],['map'])

                load['loading_biom'][0]+=1
                if load['loading_biom'][0] >= tut.SIZE_TERRAIN[0]:
                    load['loading_biom'][0] = 0
                    load['loading_biom'][1]+= 1
                    if load['loading_biom'][1] >= tut.SIZE_TERRAIN[1]:
                        go_on = True

                add_per = True

                self.loadbar['plus'] = ' '+str([load['loading_biom'][0]+1,load['loading_biom'][1]+1])
                if go_on:
                    self.loadbar['plus'] = ''

            elif state == 7: ## 'creating blur effect map'

                # CREATION BLUR EFFECT MAP

                posx_effect = self.current_size_scr[0]//2 - (tut.SIZE_TERRAIN[0]*tut.SIZE_TILE[0])//2 - tut.SIZE_TILE[0]*2
                posy_effect = self.current_size_scr[1]//2 - (tut.SIZE_TERRAIN[1]*tut.SIZE_TILE[0])//2 - tut.SIZE_TILE[0]*2

                effect_terrain = []

                blur_color = random.choice([i for i in range(1,10)])
                for j in range(tut.SIZE_TERRAIN[1]+4):
                    taby = []
                    for i in range(tut.SIZE_TERRAIN[0]+4):
                        taby.append(blur_color)
                    effect_terrain.append(taby)

                self.effects.append(self.effectMan.addEffect('blur50_map',effect_terrain,(posx_effect,posy_effect),self.group_manager.orders['map']-1))
                self.effectMan.unhide('blur50_map',False)

                go_on = True
                add_per = True

            elif state == 8: ## 'resetting camera'

                self.reset_camera('ulti')

                go_on = True
                add_per = True

            elif state == 9: ## 'finishing loading'

                self.in_land = True
                self.aff_hud = True
                self.navigate('showing')
                if hasattr(self, 'created'):
                    print('TOTAL TIME CREATING/LOADING GAME :',truncate(time.time()-self.total_time_loading,3))
                    del self.created
                else:
                    print('TOTAL TIME LOADING GAME :',truncate(time.time()-self.total_time_loading,3))

                if TAKE_DIRECT_SCREEN:
                    self.create_image()

                go_on = True
                add_per = True

            #print('     state',state,truncate(time.time()-local_time,3))

            # upgrading state
            if add_per:
                add = (100 - self.loadbar['percent'])/self.loadbar['nb_ope']
                self.loadbar['percent'] += add
                self.loadbar['nb_ope'] -= 1
            self.all_times[self.load_to_do[load['state']]] += time.time()-local_time

            if go_on:
                self.loading['state']+= 1
                if self.loading['state'] >= len(self.load_to_do):
                    del self.loading
                    del self.load_to_do
                    self.graphic.delete(self.sprids['loading'])
                    self.labman.delete(self.lblids['loading'])
                    del self.sprids['loading']
                    del self.lblids['loading']
                    """print('\n')
                    for tim in self.all_times:
                        print(tim,':',self.all_times[tim])"""

            if 'loading' in self.sprids:
                ## refresh loading bar + label
                size_fill = pup.SIZ['loading_bar'][0]*self.loadbar['percent']/100
                self.labman.set_text(self.lblids['loading'],self.load_to_do[load['state']]+self.loadbar['plus'])
                self.graphic.modify(self.sprids['loading']['fill'],scale=(size_fill/SIZE_TILE,1))

        return t

    def draw(self):

        if self.actions[self.action] != 'nothing':

            self.manager.draw()

            if self.actions[self.action] == 'menu':
                self.specMan.draw(['title'])
                self.specMan.draw(self.buttons[self.actions_menu[self.action_menu]])

                if self.actions_menu[self.action_menu] == 'main':
                    self.specMan.draw(['description'])
                elif self.actions_menu[self.action_menu] == 'newmap':
                    self.specMan.draw(['size_land'])


        if self.aff_cmd:
            self.cmd.draw()

    def gameloop(self,dt):


        pyglet.clock.tick()


        if self.nb == 0:

            self.lblids['fps'] = self.labman.addLabel('FPS',(20*pup.GEN['1x'],pup.GEN['ay']-50*pup.GEN['1y']),font_size=32*pup.GEN['1y'],font_name='arial')
            self.labman.addToGroup(self.lblids['fps'],['up'],1)

        self.nb+=1
        self.labman.set_text(self.lblids['fps'],'FPS : '+str(int(pyglet.clock.get_fps())))


        if self.playing:

            #print(self.action)
            self.cmd.add(' ',self.actions[self.action])

            elapsed_time = time.time()
            ### EVENTS
            self.events()
            self.cmd.add("events",time.time() - elapsed_time)

            elapsed_time = time.time()
            ### CLEAR
            self.clear()
            self.cmd.add("clear",time.time() - elapsed_time)

            elapsed_time = time.time()
            ### refresh
            t = self.refresh()
            self.cmd.add("refresh",time.time() - elapsed_time)

            for lbl in t:
                self.cmd.add("REF "+lbl,t[lbl])

            elapsed_time = time.time()
            ### DRAW
            self.draw()
            self.cmd.add("draw",time.time() - elapsed_time)


            if self.actions[self.action] == 'showing':
                self.cmd.add('   ','')
                self.cmd.add('perso :','')
                self.cmd.add('   pos',self.persos[self.perso].pos)
                self.cmd.add('   px_pos',self.persos[self.perso].px_pos)


                self.cmd.add('    ','')
                self.cmd.add('camera :','')
                self.cmd.add('   cam',self.camera.pos )
                #self.cmd.add('   y',self.camera[1])
                self.cmd.add('   obj',self.camera.obj)
                #self.cmd.add('   objy',self.camera.obj.y)
                #self.cmd.add('   tile x',self.camera_tile[0] )
                #self.cmd.add('   tile y',self.camera_tile[1])
                #self.cmd.add('   tile obj x',self.camera_obj_tile[0] )
                #self.cmd.add('   tile obj y',self.camera_obj_tile[1])

        else:
            print('\n\nNumber of lines :',compt(self.path))
            gs.save_files(self.path)

            self.close()

def main():

    app = App()
    app.init()

if __name__ == '__main__':
    main()



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/drawable.py








import pyglet

class SprButton(pyglet.text.Label):

    def __init__(self):

        super(SprButton,self).__init__()


class LabelButton(pyglet.text.Label):

    def __init__(self,fonction,box,text,font,font_size,x,y,param=None,color=(0,0,0,255),nobig=True):

        super(LabelButton,self).__init__(text,font_name=font,font_size=font_size,x=x,y=y,color=(0,0,0,255),anchor_y='center',anchor_x= 'center')

        self.fonction = fonction
        self.standard_size = font_size
        self.standard_col = color
        self.box = box

        self.nobig = nobig
        self.here = False
        self.pressed = False
        self.param = param

    def activate(self):
        #print(self.fonction,self.param)
        if self.param == None:
            self.fonction()
        elif type(self.param) == type([]) or type(self.param) == type((0,1)):
            self.fonction(*self.param)
        else:
            self.fonction(self.param)

    def i_am_pressed(self):
        self.font_size = int(self.standard_size*(3/4))
        self.pressed = True
        self.here = True

    def i_am_released(self):
        self.color = self.standard_col
        self.font_size = self.standard_size

        self.here = False
        self.pressed = False
        self.activate()

    def the_mouse_is_here(self):
        if not self.here:
            if not self.nobig:
                self.font_size = int(self.standard_size*1.5)
            self.color = (50, 175, 225,255)
            self.here = True

    def the_mouse_is_not_here_anymore(self):
        if self.here:
            if not self.nobig:
                self.font_size = self.standard_size
            self.color = self.standard_col
            self.here = False

    def get_box(self):
        w,h = self.box
        return self.x-w,self.y-h,w*2,h*2

class WritingBar(pyglet.text.Label):

    def __init__(self,fct,box,text,font,font_size,x,y,color=(100,100,100,255)):

        super(WritingBar,self).__init__(text,font_name=font,font_size=font_size,x=x,y=y,color=color,anchor_y='center',anchor_x= 'center')

        self.fonction = fct

        self.initial_text = text

        self.standard_col = color
        self.box = box

        self.selected = False
        self.validated = False

        self.writing_color = (50,50,50,255)
        self.initial_color = (100,100,100,255)
        self.yes_color = (0,255,0,255)
        self.no_color = (255,0,0,255)

    def i_am_selected(self):

        if self.text == self.initial_text:
            self.text = ''

        self.color = self.writing_color
        self.selected = True
        self.validated = False

    def add_letter(self,res):

        self.text+=res

    def del_letter(self):
        self.text = self.text[:-1]

    def he_tried_to_validate_XO(self):

        if self.text != '':
            if self.fonction(self.text):
                self.color = self.yes_color
                self.validated = True
            else:
                self.color = self.no_color
                self.validated = False
        else:
            self.text = self.initial_text
            self.color = self.initial_color
            self.validated = False

        self.selected = False

    def put_to_zero(self):
        self.text = self.initial_text
        self.color = self.initial_color
        self.validated = False
        self.selected = False



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/getsave.py


"""""
programme sauvegarde de fichiers sources
"""""

# va de pair avec getback v3

version = 3

import os

def save_files(bigpath,path = ['/.','/src'],save_path = '/autosav/'):

    autosav = ''

    for chem in path:
        #print('path',bigpath+chem,':',os.listdir(bigpath+chem))
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    autosav += '\n\n\n _newfile_ :' + bigpath+chem+'/'+file + '\n\n\n'
                    with open(bigpath+chem+'/'+file,'r') as f:
                        autosav += f.read()
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
        version[1]+=1
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    except:
        os.makedirs(bigpath+save_path)
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

    with open(bigpath+save_path+'saved_'+version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]+'.savd','w') as f:
        f.write(autosav)

    print('files saved, version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

def get_version(bigpath,save_path = '/autosav/'):
    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
    except:
        a=0
    return version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/graphic.py






import pyglet
import src.utils as utils
import src.tile_utils as tut



#manager who rules groups to draw things in the right order u know
class GroupManager():

    def __init__(self):


        self.groups = {} ## give the group with the name

        self.names_wo = {} ## give the name with the order
        self.names_wl = {} ## give the name with the level

        self.orders = {} ## give the order with the name

        names = ['back','mid','front','hud','map','up']
        self.distance_btw = 8

        for i in range(len(names)):
            self.groups[names[i]] = pyglet.graphics.OrderedGroup(i*self.distance_btw)
            self.orders[names[i]] = i*self.distance_btw
            self.names_wo[i*self.distance_btw] = names[i]
            if i<tut.DEPTH_BIOM:
                self.names_wl[i] = names[i]

    def getOrderGroup(self,thg=['back',None,None],thg2=0):

        name=''

        if thg[0] != None: ## atteint un groupe particulier avec son nom
            name = thg[0]
        elif thg[1] != None: ## atteint un groupe particulier avec son order d'affichage
            return thg[1]
        elif thg[2] != None: ## atteint un groupe particulier en utilisant le level de l'objet à ajouter au groupe
            name = self.names_wl[thg[2]]

        if thg2 != 0:
            name += str(thg2)

        if name in self.groups:
            return self.orders[name]

        return None

    def getGroup(self,thg=['back',None,None],thg2=0):

        name = ''

        if thg[0] != None: ## atteint un groupe particulier avec son nom
            name = thg[0]
        elif thg[1] != None: ## atteint un groupe particulier avec son order d'affichage
            name = self.names_wo[thg[1]]
        elif thg[2] != None: ## atteint un groupe particulier en utilisant le level de l'objet à ajouter au groupe
            name = self.names_wl[thg[2]]

        if thg2 != 0:
            name +=str(thg2)

        if name in self.groups:
            return self.groups[name]

        return None #le groupe n'existe pas

    def createGroup(self,thg=['back',None,None],thg2=0,level_to_put_in=0):
        group = self.getGroup(thg,thg2)
        if group == None: ## pas encore de groupe créé

            if thg[0] != None:
                if thg2 == 0:
                    return self.quickCreateGroup(thg[0],level_to_put_in)
                else:
                    name = thg[0]+str(thg2)
                    return self.quickCreateGroup(name,self.orders[thg[0]]+thg2)
            elif thg[1] != None:
                try:
                    name = self.names_wo[thg[1]]+str(thg2)
                    return self.quickCreateGroup(name,thg[1]+thg2)
                except :
                    print('chien essaie de regler la creation dun groupe avec order')
            elif thg[2] != None:
                try:
                    name = self.names_wl[thg[2]]+str(thg2)
                    return self.quickCreateGroup(name,thg[2]*self.distance_btw + thg2)
                except :
                    print('chien essaie de regler la creation dun groupe avec level')

        # ah si on est là le groupe était créé
        return group

    def quickCreateGroup(self,name,order):
        if not name in self.groups:
            self.groups[name] = pyglet.graphics.OrderedGroup(order)
            self.orders[name] = order
            self.names_wo[order] = name
            return self.groups[name]
        return self.groups[name] # group was already created

#manager who init images
class MainManager():

    def __init__(self,path,size_tile=32):

        self.size_tile = size_tile

        self.textures = {}
        self.rawdata = {}

        self.ids = []

        self.batch = pyglet.graphics.Batch()
        self.path = path

    def loadImSeq(self,name,path2,sizex,sizey):

        path3 = '/item/'
        img = pyglet.image.load(self.path+path3+path2)
        textures = pyglet.image.ImageGrid(img, sizex//self.size_tile,sizey//self.size_tile)

        ids = []
        for txt in textures:
            id = utils.get_id('text')
            self.textures[id] = txt

            if name == 'ground':
                self.rawdata[id] = txt.get_data('RGBA', txt.width * len('RGBA'))

            self.ids.append(id)
            ids.append(id)
        return ids

    def loadIm(self,name,path2):

        path3 = '/item/'
        id = utils.get_id('img')
        img = pyglet.image.load(self.path+path3+path2)
        self.textures[id] = img
        self.ids.append(id)
        return id

    def draw(self):
        self.batch.draw()
        #print('hee')

#manager who rules normal sprites
class GraphManager():

    def __init__(self,textManager,group_manager,size_tile=32):

        self.size_tile = size_tile
        self.textManager = textManager

        ## GROUPES

        self.groups = group_manager

        ## SPRITES

        self.sprites = {}
        self.static_sprites = {}
        self.eff_sprites = {}

        self.ids = []

    def addSpr(self,textid,xy_pos=(0,0),alr_id=-1,vis=True,static=False,eff=False):

        if alr_id == -1:
            id = utils.get_id('spr')
            self.ids.append(id)
        else:
            id =alr_id

        if static:
            self.static_sprites[id] = pyglet.sprite.Sprite(self.textManager.textures[textid], batch=self.textManager.batch)
            self.static_sprites[id].position = xy_pos
            self.static_sprites[id].visible = vis
        elif eff:
            self.eff_sprites[id] = pyglet.sprite.Sprite(self.textManager.textures[textid], batch=self.textManager.batch)
            self.eff_sprites[id].position = xy_pos
            self.eff_sprites[id].visible = vis
        else:
            self.sprites[id] = pyglet.sprite.Sprite(self.textManager.textures[textid], batch=self.textManager.batch)
            self.sprites[id].position = xy_pos
            self.sprites[id].visible = vis

        #self.detect()

        return id

    def addToGroup(self,id,thg=['back',None,None],thg2=0,level_to_put_in=0,eff=False):

        group = self.groups.createGroup(thg,thg2,level_to_put_in)

        if not eff:
            try :
                self.sprites[id].group = group
            except:
                self.static_sprites[id].group = group
        else:
            self.eff_sprites[id].group = group

        #self.detect()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                try:
                    if self.sprites[id].visible != (not hide):
                        self.sprites[id].visible = (not hide)
                except:
                    try:
                        if self.static_sprites[id].visible != (not hide):
                            self.static_sprites[id].visible = (not hide)
                    except :
                        if self.eff_sprites[id].visible != (not hide):
                            self.eff_sprites[id].visible = (not hide)

        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)

        else:
            try:
                if self.sprites[tabids].visible != (not hide):
                    self.sprites[tabids].visible = (not hide)
            except:
                try:
                    if self.static_sprites[tabids].visible != (not hide):
                        self.static_sprites[tabids].visible = (not hide)
                except :
                    if self.eff_sprites[tabids].visible != (not hide):
                        self.eff_sprites[tabids].visible = (not hide)

    def set_text(self,sprid,textid):
        if self.sprites[sprid].image != self.textManager.textures[textid]:
            self.sprites[sprid].image = self.textManager.textures[textid]

    def modify(self,sprid,pos=None,scale=None,group=None):

        # position
        x,y = None,None
        if pos != None and pos != (self.sprites[sprid].x,self.sprites[sprid].y):
            x,y = pos

        # scale
        scalex,scaley = None,None
        if scale != None and scale != (self.sprites[sprid].scale_x,self.sprites[sprid].scale_y):
            scalex,scaley = scale

        # updating group
        if group != None:
            group = self.groups.getGroup(*group)
            if group != self.sprites[sprid].group:
                self.sprites[sprid].group = group

        # final updating positon and scale
        self.sprites[sprid].update(x=x,y=y,scale_x = scalex,scale_y=scaley)

    def spr(self,id):

        if id in self.sprites:
            return self.sprites[id]
        elif id in self.static_sprites:
            return self.static_sprites[id]
        elif id in self.eff_sprites:
            return self.eff_sprites[id]

        return None

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les sprites affichés ingame
            for id in self.sprites:
                self.sprites[id].delete()
            self.sprites = {}
            #print('sprites deleted')

        elif type(tabids) == type('aa'): # on delete un seul sprite precis
            if tabids in self.sprites:
                self.sprites[tabids].delete()
                del self.sprites[tabids]
                #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de sprite
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de sprite
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

    def detect(self):

        errorsS = []
        errorsV = []
        for id in self.sprites:
            if type(self.sprites[id]) != pyglet.sprite.Sprite:
                errorsS.append(id)
            else:
                if self.sprites[id]._vertex_list == None:
                    errorsV.append(id)
        if errorsS != []:
            print('noSprite',errorsS)
        if errorsV != []:
            print('noVertex',errorsV)


#manager who rules normal labels
class LabelManager():

    def __init__(self,textManager,group_manager,font):

        self.groups = group_manager
        self.textManager = textManager

        self.font = font

        self.labels = {}
        self.ids = []

    def addLabel(self,contenu,xy_pos=(0,0),alr_id=-1,vis=True,font_name=None,font_size=30,group=None,anchor = ('left','bottom'),color=(255,255,255,255)):

        if alr_id == -1:
            id = utils.get_id('lbl')
            self.ids.append(id)
        else:
            id =alr_id

        if not font_name:
            font_name = self.font


        anchor_x,anchor_y= anchor

        #group = self.groups.createGroup(['hud'])
        self.labels[id] = pyglet.text.Label(contenu,font_name=font_name,font_size=font_size,group=group, \
                        batch=self.textManager.batch,anchor_x= anchor_x,anchor_y= anchor_y,color=color)
        self.labels[id].x,self.labels[id].y = xy_pos
        self.unhide(id,not vis)
        #self.labels[id].visible = vis

        return id

    def addToGroup(self,id,thg=['back',None,None],thg2=0,level_to_put_in=0):

        group = self.groups.createGroup(thg,thg2,level_to_put_in)
        #print('GROUP IS',group)
        self.labels[id]._init_groups(group)
        self.labels[id]._update()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                self.unhide(id,hide)
        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)
        else:
            if hide == False and self.labels[tabids].color[3] == 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],255]
            elif hide == True and self.labels[tabids].color[3] != 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],0]

    def set_text(self,lblid,contenu):
        if self.labels[lblid].text != contenu:
            self.labels[lblid].text = contenu

    def printGroup(self,lblid):
        print('\ttopgroup :',self.labels[lblid].top_group)
        print('\tbackgroup :',self.labels[lblid].background_group)
        print('\tforegroup :',self.labels[lblid].foreground_group)
        print('\tforegroupdeco :',self.labels[lblid].foreground_decoration_group)

    def modify(self,lblid,pos=None,scale=None):

        if scale != None and scale != (self.labels[lblid].scale_x,self.labels[lblid].scale_y):
            self.labels[lblid].update(scale_x = scale[0],scale_y=scale[1])
            #self.labels[lblid].scale_x,self.labels[lblid].scale_y = scale

        if pos != None and pos != (self.labels[lblid].x,self.labels[lblid].y):
            self.labels[lblid].x,self.labels[lblid].y = pos

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les labels affichés ingame
            for id in self.labels:
                self.labels[id].delete()
            self.labels = {}
            #print('labels deleted')

        elif type(tabids) == type('aa'): # on delete un seul label precis
            self.labels[tabids].delete()
            del self.labels[tabids]
            #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de label
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de label
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

#special manager who rules effects sprites
class EffectManager():

    def __init__(self,graphic,textids,size_tile=32):

        self.effects = {}
        #self.groups = {}
        #self.sprites = {}

        self.sprids = {}

        self.size_tile = size_tile

        self.graphic = graphic
        self.textids = textids

    def addEffect(self,name,terrain,dep_pos,order):

        self.effects[name] = terrain
        #self.groups[name] = pyglet.graphics.OrderedGroup(order)

        """created = self.graphic.createGroup(name,order,eff=True)
        if not created:
            self.delete(name)"""

        self.sprids[name] = []

        for j in range(len(terrain)):
            for i in range(len(terrain[j])):
                posx = dep_pos[0] + i*self.size_tile
                posy = dep_pos[1] + j*self.size_tile
                id = self.graphic.addSpr(self.textids[terrain[j][i]],(posx,posy),eff=True)
                self.graphic.addToGroup(id,[name],0,order,True)
                #print('creating',name,id)
                self.sprids[name].append(id)
                #self.sprites[name].append(pyglet.sprite.Sprite(self.textManager.textures[] , batch = self.textManager.batch , group=self.groups[name], x=posx,y=posy  ))
        return name

    def unhide(self,name,hide=False):
        self.graphic.unhide(self.sprids[name],hide)

    def delete(self,name):
        #print(self.sprids[name])
        #print('deleting',name)
        for spr in self.sprids[name]:
            #print('deleting',name,spr)
            self.graphic.eff_sprites[spr].delete()

    def hasEffect(self,name):
        return name in self.effects

#special manager who rules labels I need to see what's wrong (it's my own cmd)
class CmdManager():

    def __init__(self,pos):

        self.batch = pyglet.graphics.Batch()

        self.data = {}
        self.pos = {}
        self.labels = {}
        self.name = ['main','main2']
        for name in self.name:
            self.data[name] = {}
            self.pos[name] = {}
            self.labels[name] = {}


        self.init_pos = pos

        self.font = 'arial'
        self.size_ft = 20

    def draw(self,name='main'):
        self.batch.draw()

    def add(self,lab,data,name='main'):

        already_in = False

        try:
            type(self.data[name][lab])
            already_in = True
        except :
            self.pos[name][lab] = [self.init_pos[0],self.init_pos[1]-25]
            self.init_pos = self.pos[name][lab]

        if type(data) == type(0.001):
            self.data[name][lab] = utils.truncate(data,3)
        else:
            self.data[name][lab] = data

        if not already_in:
            self.labels[name][lab] = pyglet.text.Label(lab+' '+str(self.data[name][lab]),
                            font_name=self.font,
                            font_size=self.size_ft,
                            x=self.pos[name][lab][0],
                            y=self.pos[name][lab][1],
                            batch=self.batch)
        else:
            self.labels[name][lab].text = lab+' '+str(self.data[name][lab])

#special manager for single uses : buttons in menu
class SpecialManager():

    def __init__(self,manager,scrsize):

        self.manager = manager
        self.screen = scrsize

        self.to_draw = {}
        #self.order = []

    def addSpr(self,textid,x,y,name=utils.get_id('spc')):

        thg = pyglet.sprite.Sprite(self.manager.textures[textid])
        thg.position = x,y

        self.to_draw[name] = thg

        return name

    def addLabel(self,text,font_name,font_size,x,y,name=utils.get_id('spc'),color=(0,0,0,255)):
        thg = pyglet.text.Label(text,
                        font_name=font_name,
                        font_size=font_size,
                        anchor_x= 'center',
                        color=color,
                        x=x,y=y)

        self.to_draw[name] = thg

        return name

    def addThg(self,thg,name=utils.get_id('spc')):

        self.to_draw[name] = thg
        return name

    def draw(self,tab):

        for name in tab:
            self.to_draw[name].draw()

## OTHER GRAPHICS CLASS

class Cursor():

    def __init__(self,name,graph,text,skin,thg,thg2=0,pos=(0,0),vis=True):

        self.name = name

        self.textids = text
        self.skin = skin
        self.manager = graph
        id = self.manager.addSpr(self.textids[self.skin],pos,vis=vis)
        self.manager.addToGroup(id,thg,thg2)
        self.order = self.manager.groups.getOrderGroup(thg,thg2)
        self.has_ani = False
        self.id = id

        #return id

    def set_pos(self,pos):
        self.manager.sprites[self.id].position = pos

    def get_pos(self):
        return self.manager.sprites[self.id].position

    def set_ani(self,ani,time=2,skin=0):
        self.has_ani = True
        self.ani = ani
        self.time=time
        self.temp = 0
        self.skin = skin
        self.maj_ani()

    def set_text(self,skin):
        self.has_ani = False
        self.skin = skin
        self.maj_ani()

    def up_skin(self,key=[1]):
        if self.has_ani:
            if key[0] != None:
                self.temp+=key[0]
                if self.temp >= self.time:
                    a = self.temp//self.time
                    self.temp-=(self.time*a)
                    self.skin+=a
                if self.skin >= len(self.ani):
                    self.skin -= len(self.ani)
                elif self.skin < 0:
                    self.skin += len(self.ani)
            elif key[1] != None:
                self.skin=key[1]
                if self.skin >= len(self.ani):
                    self.skin = len(self.ani) - 1
                elif self.skin < 0:
                    self.skin = 0


            self.maj_ani()

    def maj_ani(self):
        if self.manager.sprites[self.id].visible:
            if self.has_ani:
                self.manager.set_text(self.id,self.textids[self.ani[self.skin]])
            else:
                self.manager.set_text(self.id,self.textids[self.skin])

    def delete(self):
        self.manager.delete(self.id)

    def unhide(self,hide=False):
        self.manager.unhide(self.id,hide)

    def is_visible(self):
        return self.manager.sprites[self.id].visible



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/item.py




import src.tile_utils as tut
from src.utils import *
from src.TerrainCreator import REVERSE_DIC

class Item():

    def __init__(self,key, name):

        self.key = key
        self.name = name
        self.sprid = ''
        self.has_sprid = False
        self.is_stockable = False
        self.amount = 1

        self.time = [None,None]

    def set_spr(self,id):

        self.sprid = id
        self.has_sprid = True

    def del_sprid(self):
        self.sprid = ''
        self.has_sprid = False

    def act(self,case):

        #print(self.name,'acting on the',case,'case')
        return 0

    def ract(self,case):

        #print(self.name,'racting on the',case,'case')
        return 0

class Hand(Item):

    def __init__(self,perso,key=0, name='Hand'):

        super(Hand,self).__init__(key, name)
        self.perso = perso

        self.time = [10,0]

    def act(self,case):

        #print('grabbing',case)
        self.perso.grab(case)
        return 1

    def ract(self,case):

        #print(case)

        #print('This is',REVERSE_DIC[self.perso.terrain.get_case(case,case.l)][0])
        return 0

class Stackable(Item):

    def __init__(self,perso,key,name,amount=1,max=64):

        super(Stackable,self).__init__(key, name)

        self.perso = perso
        self.max_amount = max
        self.amount = amount
        self.is_stockable = True
        self.sprid_amount = ''
        self.amt_changed = False

        self.time = [None,0]

    def set_spr(self,id,amt_id):

        super(Stackable,self).set_spr(id)
        self.sprid_amount = amt_id

    def add(self,amt):

        if self.amount == self.max_amount and amt>0:
            return True,amt

        a = self.amount + amt
        if a < 0:
            old = self.amount
            self.amount = 0
            self.amt_changed = True
            return False,a-old
        elif a == 0:
            self.amount = a
            self.amt_changed = True
            return False,0
        elif a > self.max_amount:
            self.amount = self.max_amount
            self.amt_changed = True
            return True,a-self.max_amount
        else:
            self.amount = a
            self.amt_changed = True
            return True,0

    def ract(self,case):

        self.perso.place(case)
        return 1

    def del_sprid(self):

        super(Stackable,self).del_sprid()
        self.sprid_amount = ''



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/none.py











self.goodkeys = {key.SPACE : ' ',key.EXCLAMATION : '!',key.DOUBLEQUOTE : '\"',key.HASH : "#"
                ,key.POUND : '£',key.DOLLAR : '$',key.PERCENT : '%',key.AMPERSAND : '*'
                ,key.APOSTROPHE : '\'',key.PARENLEFT : '(',key.PARENRIGHT : ')',key.ASTERISK : '*'
                ,key.PLUS : '+',key.COMMA : '*',key.MINUS : '*',key.PERIOD : '*',key.SLASH : '\\',key._0 : '0'
                ,key._1 : '1',key._2 : '2',key._3 : '3',key._4 : '4',key._5 : '5',key._6 : '6',key._7 : '7',key._8 : '8',key._9 : '9'
                ,key.COLON : '*',key.SEMICOLON : '*',key.LESS : '-',key.EQUAL : '=',key.GREATER : '*',key.QUESTION : '?',key.AT : '@'
                ,key.BRACKETLEFT : '[',key.BACKSLASH : '/',key.BRACKETRIGHT : ']',key.ASCIICIRCUM : '*',key.UNDERSCORE : '_',key.GRAVE : '`'
                ,key.QUOTELEFT : '<',key.A : 'a',key.B : 'b',key.C : 'c',key.D : 'd',key.E : 'e',key.F : 'f',key.G : 'g',key.H : 'h',key.I : 'i'
                ,key.J : 'j',key.K : 'k',key.L : 'l',key.M : 'm',key.N : 'n',key.O : 'o',key.P : 'p',key.Q : 'q',key.R : 'r',key.S : 's'
                ,key.T : 't',key.U : 'u',key.V : 'v',key.W : 'w',key.X : 'x',key.Y : 'y',key.Z : 'z',key.BRACELEFT : '{',key.BAR : '|'
                ,key.BRACERIGHT : '}',key.ASCIITILDE : '*'}












 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/perso.py







import random,time
import src.tile_utils as tut
import src.positions as pup
import src.species as sp
from src.utils import *
import src.item as item
import src.TerrainCreator as tc


CMD = False

## VIVANTS GENERAUX

class Living():

    def __init__(self,terrain,labman,bcx_box=None,specie='loutre',name=None,skin_seq=None):

        self.terrain = terrain
        self.labman = labman

        ## GENERAL
        if name != None:
            self.name = name
        else:
            self.name = choice(sp.dic[specie]['names'])
        self.life = sp.dic[specie]['life']
        self.max_life = sp.dic[specie]['life']
        self.dead = False

        self.specie = specie



        ## POS
        if bcx_box == None:
            self.pos = self.terrain.get_random_case(1)
            self.size = tut.from_xy_to_bcx(tut.XY_Size(*sp.dic[specie]['size']))
            self.box = tut.BCX_Box(*self.pos.bcx(),self.pos.lvl(),*self.size.bcx())
        else:
            self.pos = bcx_box.Pos()
            self.size = bcx_box.Size()   #(c=(1,1))#),p=(32-6,0)) ## le perso est un peu plus petit qu'une tile pour des raisons pratiques
            self.box = bcx_box

        self.coll_box = []


        ## SKINS
        self.dirs = {(0,1):'up',(0,-1):'down',(1,0):'right',(-1,0):'left'}

        if skin_seq == None:
            self.skin_dic = sp.dic[self.specie]['skin_seq']
        else:
            self.skin_dic = skin_seq
        self.skin_seq = 'down'
        self.skin_var = 0
        self.skin_time = time.time()
        self.skin_changing_time = 0.1
        self.skin = self.skin_dic['down'][0]

        self.plusposskin = [32,33]
        self.show_line = False

        ## SPEED
        self.speed = sp.dic[self.specie]['speed']

        ## SKILLS
        self.skills = sp.dic[self.specie]['skills']

        ## WALKABLE
        self.WALKON = {}
        self.WALKTRGH = {}
        for skill in self.skills:
            if skill in tc.WALKON:
                self.WALKON[skill] = tc.WALKON[skill]
            if skill in tc.WALKTRGH:
                self.WALKTRGH[skill] = tc.WALKTRGH[skill]

        self.actualise_pos()


    ## fonctions generales

    def actualise_general(self):

        if self.life <= 0:
            self.dead = True
        else:
            self.dead = False
        if CMD:
            self.infos()

    def infos(self):

        s = ''
        #s+= "infos de "
        #s+=str(self.name)
        s+="\n vie : "
        s+=str(self.life)+' / '+str(self.max_life)
        #s+= "\n pos : "+str(self.pos)
        #print(s)
        self.labman.add('infos de '+self.name,s)

    ## fonctions GAMEPLAY

    def adelife(self,qty):

        self.life = float(truncate(self.life+qty))
        if self.life < 0:
            self.life = 0
        elif self.life > self.max_life:
            self.life = self.max_life

    def adelife_max(self,qty,fill=False):
        self.max_life = float(truncate(self.max_life+qty))
        if fill or self.life > self.max_life:
            self.life = self.max_life


    ## fonctions MOVING, POSITION ...

    def actualise_pos(self):

        """ya mooyen c'est pas optimizé au maax"""


        ## PARTIE PX POS

        self.px_pos = tut.from_bcx_to_xy(self.pos)

        ## PARTIE ACTUALS CASES

        self.actual_cases = []
        self.px_actual_cases = []
        self.coll_box = []


        for i in range(2):
            for j in range(2):
                vec = tut.BCX_Vec(c=[i,j])
                pos_case = tut.bcx_add(self.pos,vec)
                pos_case.x[2] = 0
                pos_case.y[2] = 0

                if pos_case.x[0] >= 0 and pos_case.x[0] < tut.SIZE_TERRAIN[0] and pos_case.y[0] >= 0 and pos_case.y[0] < tut.SIZE_TERRAIN[1]:
                    coll = False
                    for lvl in [self.pos.lvl(),self.pos.lvl()-1]:
                        if lvl >= 0:
                            #print(i,j,lvl,'    :::',self.terrain.get_case(pos_case,lvl))
                            if lvl == self.pos.lvl():
                                if self.terrain.get_case(pos_case,lvl) != 0 or (self.terrain.get_case(pos_case,lvl) == 0 and lvl == 0):
                                    #if not self.terrain.get_case(pos_case,lvl) in tc.SOLIDITE[0]: ### SI ON ARRIVE PAS A MARCHER DEDANS car pas les skills
                                    #    #self.labman.add(str(i)+' '+str(j)+'  '+str(lvl)+'::: solid',tc.REVERSE_DIC[self.terrain.get_case(pos_case,lvl)][0])
                                    if not self.can_walk_through(self.terrain.get_case(pos_case,lvl)):
                                        coll = True
                            else:
                                if self.terrain.get_case(pos_case,lvl) != 0 or (self.terrain.get_case(pos_case,lvl) == 0 and lvl == 0):
                                    #if not self.terrain.get_case(pos_case,lvl) in tc.WALKABLE[0]: ### SI ON ARRIVE PAS A MARCHER DESSUS car pas les skills
                                    #    #self.labman.add(str(i)+' '+str(j)+'  '+str(lvl)+'::: not walkable',tc.REVERSE_DIC[self.terrain.get_case(pos_case,lvl)][0])
                                    if not self.can_walk_on(self.terrain.get_case(pos_case,lvl)):
                                        coll = True
                        else:
                            coll = True



                    if coll:
                        self.coll_box.append( tut.from_bcx_to_xy(tut.BCX_Box(*pos_case.bcx(),pos_case.lvl(),[0,0],[1,1],[0,0])))
                        #self.coll_box.append( tut.from_bcx_to_xy(tut.BCX_Box(*pos_case.bcx(),pos_case.lvl(),c2=[1,1])))
                else:
                    self.coll_box.append( tut.from_bcx_to_xy(tut.BCX_Box(*pos_case.bcx(),pos_case.lvl(),[0,0],[1,1],[0,0])))

                self.actual_cases.append(pos_case)
                px_pos = tut.from_bcx_to_xy(pos_case)
                self.px_actual_cases.append(px_pos)

        #self.labman.add('actual_cases',(len(self.actual_cases),self.actual_cases))
        ## PARTIE NEAR CASES


        self.near_cases = {}
        self.px_near_cases = []
        tab = [ (0,2),(0,1),(1,3),(1,0), (2,0),(2,3),(3,1),(3,2) ]
        for k in range(len(tab)):

            i,j = tab[k]

            pos_case = tut.BCX_Pos()
            vec = tut.BCX_Vec()

            d = 1
            if i%2 == j%2:
                if i%2 != 0:
                    d = -1
                vec = tut.BCX_Vec(c=[0,-d])
            else:
                if i < 2:
                    d = -1
                vec = tut.BCX_Vec(c=[d,0])


            pos_case = tut.bcx_add(self.actual_cases[i],vec)
            if pos_case.x[0] >= 0 and pos_case.x[0] < tut.SIZE_TERRAIN[0] and pos_case.y[0] >= 0 and pos_case.y[0] < tut.SIZE_TERRAIN[1]:
                coll = False
                for lvl in [self.pos.lvl(),self.pos.lvl()-1]:
                    if lvl >= 0:
                        #print(i,j,lvl,'    :::',self.terrain.get_case(pos_case,lvl))
                        #self.labman.add(str(i)+' '+str(j)+'  '+str(lvl)+':::',(not self.terrain.get_case(pos_case,lvl) in self.good_ground,self.terrain.get_case(pos_case,lvl) != '0'))
                        if lvl == self.pos.lvl():
                            if self.terrain.get_case(pos_case,lvl) != 0 or (self.terrain.get_case(pos_case,lvl) == 0 and lvl == 0):
                                #if not self.terrain.get_case(pos_case,lvl) in tc.SOLIDITE[0]:
                                if not self.can_walk_through(self.terrain.get_case(pos_case,lvl)):
                                    coll = True
                        else:
                            if self.terrain.get_case(pos_case,lvl) != 0 or (self.terrain.get_case(pos_case,lvl) == 0 and lvl == 0):
                                #if not self.terrain.get_case(pos_case,lvl) in tc.WALKABLE[0]:
                                if not self.can_walk_on(self.terrain.get_case(pos_case,lvl)):
                                    coll = True
                    else:
                        coll = True

                if coll:
                    self.coll_box.append( tut.from_bcx_to_xy(tut.BCX_Box(*pos_case.bcx(),pos_case.lvl(),[0,0],[1,1],[0,0])))
            else:
                self.coll_box.append( tut.from_bcx_to_xy(tut.BCX_Box(*pos_case.bcx(),pos_case.lvl(),[0,0],[1,1],[0,0])))

            self.near_cases[(i,j)] = pos_case
            px_pos = tut.from_bcx_to_xy(pos_case)
            self.px_near_cases.append(px_pos)

        self.box = tut.BCX_Box(*self.pos.bcx(),self.pos.lvl(),*self.size.bcx())
        #self.labman.add('FCKKYE',choice([0,1]))

    def actualise_skin(self):


        if self.skin_var >= len(self.skin_dic[self.skin_seq]):
            self.skin_var = 1
        elif self.skin_var < 0:
            self.skin_var = len(self.skin_dic[self.skin_seq])-1

        if self.skin != self.skin_dic[self.skin_seq][self.skin_var]:
            self.skin = self.skin_dic[self.skin_seq][self.skin_var]

    def move(self,dir,speedup=False,admin=False):

        if CMD:
            self.labman.add('       collbox : ',self.coll_box)
            self.labman.add('       collnb : ',str(len(self.coll_box))+' collisions')

        if speedup:
            speed = int(self.speed*1.5)
        else:
            speed = self.speed

        vec_depl = tut.XY_Vec(dir[0]*speed,dir[1]*speed)

        if not self.dead:
            self.skin_seq = self.dirs[(dir[0],dir[1])]
            t = time.time()
            if t-self.skin_time >= self.skin_changing_time:
                self.skin_var+=1
                self.skin_time = t

            if self.name == 'Legend':
                self.labman.add('skin Legend set to :',self.dirs[(dir[0],dir[1])])
            self.actualise_skin()

        moving = False

        if admin:
            moving = True
        else:

            go = True
            for collibox in self.coll_box:
                if not tut.algo_colli_XY(tut.from_bcx_to_xy(self.box),vec_depl,collibox):

                    x,y = 0,0
                    continu = True

                    while x < abs(vec_depl.x) and continu:
                        if not tut.algo_colli_XY(tut.from_bcx_to_xy(self.box),tut.XY_Vec(sign(vec_depl.x)*x,vec_depl.y),collibox):
                            if x != 0:
                                vec_depl.x = sign(vec_depl.x)*x -sign(vec_depl.x)*1
                            continu = False
                        x+=1

                    continu = True

                    while y < abs(vec_depl.y) and continu:
                        if not tut.algo_colli_XY(tut.from_bcx_to_xy(self.box),tut.XY_Vec(vec_depl.x,sign(vec_depl.y)*y),collibox):
                            if y!=0:
                                vec_depl.y = sign(vec_depl.y)*y -sign(vec_depl.y)*1
                            continu = False
                        y+=1

                    if x == 1 and y == 1:
                        go = False


            if go:
                moving = True


        if moving and not self.dead:
            self.pos = tut.bcx_add(self.pos,tut.from_xy_to_bcx(vec_depl))
            self.actualise_pos()

    def can_walk_on(self,cas):

        for skill in self.WALKON:
            if cas in self.WALKON[skill]:
                return True
        return False

    def can_walk_through(self,cas):

        for skill in self.WALKTRGH:
            if cas in self.WALKTRGH[skill]:
                return True
        return False

    ## fonctions speciales sauvegarde

    def get_biom(self):
        return self.pos.bcx()[0]

class Perso(Living):

    def __init__(self,textids,nb_textids,graphic,terrain,labman,bcx_box=None,specie='human',name=None,skin_seq=None):

        super(Perso,self).__init__(terrain,labman,bcx_box,specie,name,skin_seq)

        ## TEXTIDS GRAPH LABM TERR
        self.textids = textids
        self.numbers_textids = nb_textids
        self.graphic = graphic


        ## SELECTION
        self.selection = []
        self.limit_sel = 1
        self.inv_selection = []

        ## INVENTORY
        self.updatelist = []
        self.hand = item.Hand(self)
        self.tool = 0

        self.size_invent = 10,10
        self.inventory = {}
        self.invent_pxx = {}
        self.invent_pxx_box = {}
        self.flemmetavu = [i for i in range(self.size_invent[0])]
        for j in range(self.size_invent[1]):
            for i in range(self.size_invent[0]):
                if j==0:
                    self.inventory[i] = 0
                    self.invent_pxx[i] = pup.POS['hud_inventory_cursor_bar'][0] + 5*i*pup.GEN['10x'],pup.POS['hud_inventory_cursor_bar'][1]
                    self.invent_pxx_box[i] = tut.XY_Box(pup.POS['hud_inventory_cursor_bar'][0] + 5*i*pup.GEN['10x'],pup.POS['hud_inventory_cursor_bar'][1],*pup.SIZ['hud_inventory_selection'])
                self.flemmetavu.append((i,j))
                self.inventory[(i,j)] = 0
                self.invent_pxx[(i,j)] = pup.POS['hud_inventory_cursor_big'][0] + 5*i*pup.GEN['10x'],pup.POS['hud_inventory_cursor_big'][1]+j*5*pup.GEN['10y']
                self.invent_pxx_box[(i,j)] = tut.XY_Box(pup.POS['hud_inventory_cursor_big'][0] + 5*i*pup.GEN['10x'],pup.POS['hud_inventory_cursor_big'][1]+j*5*pup.GEN['10y'],*pup.SIZ['hud_inventory_selection'])

        self.aff_inv = False
        self.portee = 400

    ## fct selectives

    def select(self,thg):

        #print(thg)
        bcx_pos = tut.BCX_Pos()
        if type(thg) == tut.XY_Pos:
            bcx_pos = tut.from_xy_to_bcx(thg)

            lvl = tut.DEPTH_BIOM-1
            while lvl > 0 and self.terrain.get_case(bcx_pos,lvl) == 0 :
                lvl -=1

            if lvl >= 0:
                bcx_pos.l = lvl

        elif type(thg) == tut.BCX_Pos:
            bcx_pos = thg

        bcx_pos.x[2] = 0
        bcx_pos.y[2] = 0

        #bcx_size =tut.BCX_Size(c=(1,1))

        #self.labman.add('selected',(bcx_pos,self.terrain.get_case(bcx_pos)))
        if tut.biom_in_terrain([bcx_pos.x[0],bcx_pos.y[0]]):
            box = tut.BCX_Box(*bcx_pos.bcx(),bcx_pos.lvl(),[0,0],[1,1],[0,0])
            if not box in self.selection:
                self.selection.append(box)
                while len(self.selection) > self.limit_sel:
                    self.selection = self.selection[1:]
                return True
            else:
                return False
            #self.labman.add('invent',self.selection)

    def in_inv_select(self,rlpos):

        if type(rlpos) != tut.XY_Pos:
            rlpos = tut.XY_Pos(*rlpos)

        for thg in self.inventory:
            if tut.colli_ABP_XY(self.invent_pxx_box[thg],rlpos):
                if not thg in self.inv_selection:
                    self.inv_selection = [thg]
                    return True
                else:
                    return False

    def update_skin(self,mouse_pos):
        if not self.dead:
            x,y = tut.xy_add(mouse_pos,tut.from_bcx_to_xy(self.pos),-1).xy()
            if y == 0:
                y=1
            #self.labman.add('vec moved mouse',vec)

            dif = abs(x / y)

            if dif >=1:
                if x >= 0:
                    self.skin_seq = 'right'
                else:
                    self.skin_seq = 'left'
            else:
                if y >= 0:
                    self.skin_seq = 'up'
                else:
                    self.skin_seq = 'down'
            self.actualise_skin()

    def in_inv_grab(self):
        if self.inv_selection != []:
            self.inv_sel_grabbed = [*self.inv_selection]
            #print('GRAABEDD',self.inv_sel_grabbed)


    def in_inv_drop(self):
        if self.inv_sel_grabbed != [] and self.inv_selection != []:
            init_pos = self.inv_sel_grabbed[0]
            end_pos = self.inv_selection[0]

            if self.inventory[init_pos] != 0 and self.inventory[init_pos].has_sprid:
                self.graphic.delete(self.inventory[init_pos].sprid)
                if self.inventory[init_pos].is_stockable:
                    self.graphic.delete(self.inventory[init_pos].sprid_amount)
                self.inventory[init_pos].del_sprid()

            if self.inventory[end_pos] != 0 and self.inventory[end_pos].has_sprid:
                self.graphic.delete(self.inventory[end_pos].sprid)
                if self.inventory[end_pos].is_stockable:
                    self.graphic.delete(self.inventory[end_pos].sprid_amount)
                self.inventory[end_pos].del_sprid()



            self.inventory[init_pos],self.inventory[end_pos] = self.inventory[end_pos],self.inventory[init_pos]
            #print('SWAAP',init_pos,'and',end_pos)




            self.check_inventory(end_pos)
        self.check_inventory(init_pos)

    ## fct des actions

    def get_action_time(self,act):

        #print(self.inventory[self.tool].time,self.hand.time)
        if not self.dead:
            if act == 'L':
                if self.inventory[self.tool] != 0:
                    if self.inventory[self.tool].time[0] != None:
                        return self.inventory[self.tool].time[0]
                    else:
                        return self.hand.time[0]
                else:
                    return self.hand.time[0]
            elif act == 'R':
                if self.inventory[self.tool] != 0:
                    if self.inventory[self.tool].time[1] != None:
                        return self.inventory[self.tool].time[1]
                    else:
                        return self.hand.time[1]
                else:
                    return self.hand.time[1]
        else:
            return 0

    def act(self,xy_pos,way='L'):

        if not self.dead:

            bcx_pos = tut.from_xy_to_bcx(xy_pos)
            bcx_pos.x[2],bcx_pos.y[2] =0,0
            xy_pos = tut.from_bcx_to_xy(bcx_pos)
            xy_vec = tut.XY_Vec(  xy_pos.x-tut.from_bcx_to_xy(self.pos).x , xy_pos.y-tut.from_bcx_to_xy(self.pos).y  )
            #print(tut.module_XY(xy_vec))

            lvl = tut.DEPTH_BIOM-1
            while lvl > 0 and self.terrain.get_case(bcx_pos,lvl) == 0 :
                lvl -=1
            if lvl >= 0:
                bcx_pos.l = lvl

            #print(bcx_pos)

            if way == 'L':
                if tut.module_XY(xy_vec) <= self.portee:
                    #print(self.inventory[self.tool])
                    if self.inventory[self.tool] != 0:
                        ok = self.inventory[self.tool].act(bcx_pos)
                        if ok == 0:
                            self.hand.act(bcx_pos)
                    else:
                        self.hand.act(bcx_pos)
                    #self.labman.add('acting',bcx_pos)
                #else:
                #    self.labman.add('acting','too far !')

            elif way == 'R':
                if tut.module_XY(xy_vec) <= self.portee:
                    #print(self.inventory[self.tool])
                    if self.inventory[self.tool] != 0:
                        ok = self.inventory[self.tool].ract(bcx_pos)
                        if ok == 0:
                            self.hand.ract(bcx_pos)
                    else:
                        self.hand.ract(bcx_pos)
                    #self.labman.add('racting',bcx_pos)
                #else:
                #    self.labman.add('racting','too far !')

    def grab(self,bcx_pos):

        if tut.biom_in_terrain([bcx_pos.x[0],bcx_pos.y[0]]):

            lvl = tut.DEPTH_BIOM-1
            while lvl >= 0 and self.terrain.get_case(bcx_pos,lvl) == 0 :
                lvl -=1
            if lvl >= 0:
                bcx_pos.l = lvl
            else:
                return 0

            grabbed = item.Stackable(self,self.terrain.get_case(bcx_pos,lvl),get_id(tc.REVERSE_DIC[self.terrain.get_case(bcx_pos)][0]))
            to_up = self.add_to_inventory(grabbed)
            #print(to_up)
            for thg in to_up:
                self.check_inventory(thg)

            #print('ahah!3')
            if len(to_up) > 0:
                self.updatelist.append(bcx_pos)
                self.terrain.set_case(bcx_pos,0)
            else:
                print('no place left in the inventory !')

    def place(self,bcx_pos):

        if tut.biom_in_terrain([bcx_pos.x[0],bcx_pos.y[0]]):

            lvl = tut.DEPTH_BIOM-1
            while lvl >= 0 and self.terrain.get_case(bcx_pos,lvl) == 0 :
                lvl -=1
            if lvl >= 0:
                bcx_pos.l = lvl
            else:
                bcx_pos.l = -1
            #print('lvl =',lvl)


            if self.inventory[self.tool].amount > 0:

                if self.terrain.verify(bcx_pos,self.inventory[self.tool].key):
                    bcx_pos.l += 1
                    self.terrain.set_case(bcx_pos,self.inventory[self.tool].key)
                    self.updatelist.append(bcx_pos)

                    if self.inventory[self.tool].is_stockable:
                        self.inventory[self.tool].add(-1)
                    else:
                        self.inventory[self.tool].amount = 0
                    #self.labman.add('Placing',(bcx_pos,self.inventory[self.tool].amount))


            self.check_inventory(self.tool)

    ## fct de l'inventaire

    def add_to_inventory(self,item):

        to_update = []
        if item.is_stockable:

            stacks = []
            for thg in self.flemmetavu:
                if self.inventory[thg] != 0:
                    if item.key == self.inventory[thg].key:
                        stacks.append(thg)
            for thg in stacks:
                to_update.append(thg)
                ok , item.amount = self.inventory[thg].add(item.amount)
                if (ok,item.amount) == (True,0):
                    return to_update

        for thg in self.flemmetavu:
            if self.inventory[thg] == 0:
                self.inventory[thg] = item
                to_update.append(thg)
                return to_update
        return to_update

    def check_inventory(self,thg):

        if self.inventory[thg] != 0:

            if self.inventory[thg].amount <= 0 :
                if self.inventory[thg].has_sprid:
                    self.graphic.delete(self.inventory[thg].sprid)
                    if self.inventory[thg].is_stockable:
                        self.graphic.delete(self.inventory[thg].sprid_amount)
                self.inventory[thg] = 0
            else:
                if not self.inventory[thg].has_sprid:
                    sprid = self.graphic.addSpr( self.textids[self.inventory[thg].key], self.invent_pxx[thg],vis=self.aff_inv)
                    self.graphic.addToGroup(sprid,['hud'])

                    if self.inventory[thg].is_stockable:
                        sprid2 = self.graphic.addSpr( self.numbers_textids[self.inventory[thg].amount], self.invent_pxx[thg],vis=self.aff_inv)
                        self.graphic.addToGroup(sprid2,['hud'],4)
                        self.inventory[thg].set_spr(sprid,sprid2)
                    else:
                        self.inventory[thg].set_spr(sprid)
                else:
                    if self.inventory[thg].is_stockable:
                        if self.inventory[thg].amt_changed:
                            self.graphic.delete(self.inventory[thg].sprid_amount)
                            self.inventory[thg].sprid_amount = self.graphic.addSpr( self.numbers_textids[self.inventory[thg].amount], self.invent_pxx[thg],vis=self.aff_inv)
                            self.graphic.addToGroup(self.inventory[thg].sprid_amount,['hud'],4)
                            self.inventory[thg].amt_changed = False

    def toggle_inv(self):
        if self.aff_inv:
            for thg in self.flemmetavu:
                if self.inventory[thg] != 0:
                    self.graphic.sprites[self.inventory[thg].sprid].visible = False
                    if self.inventory[thg].is_stockable:
                        self.graphic.sprites[self.inventory[thg].sprid_amount].visible = False
        else:
            for thg in self.flemmetavu:
                if self.inventory[thg] != 0:
                    self.graphic.sprites[self.inventory[thg].sprid].visible = True
                    if self.inventory[thg].is_stockable:
                        self.graphic.sprites[self.inventory[thg].sprid_amount].visible = True
        self.aff_inv = not self.aff_inv

    def scroll_tool(self,nb):

        self.tool += nb
        if self.tool < 0:
            self.tool += self.size_invent[0]
        elif self.tool >= self.size_invent[0]:
            self.tool -= self.size_invent[0]

    ## fonctions speciales sauvegarde

    def get_inv(self):

        dic = {}
        for pos in self.inventory:
            if self.inventory[pos] != 0:
                if type(pos) == int:
                    pos2 = str(pos)
                else:
                    pos2 = str(pos[0])+','+str(pos[1])
                dic[pos2] = [self.inventory[pos].key ,self.inventory[pos].amount]

        return dic

    def set_inv(self,dic):

        #print(self.inventory)
        for pos in dic:
            #print('pos',pos)
            if not ',' in pos:
                pos2 = int(pos)
            else:
                pos2 = pos.split(',')
                pos2 = (int(pos2[0]),int(pos2[1]))
            self.inventory[pos2] = item.Stackable(self,dic[pos][0],get_id(tc.REVERSE_DIC[dic[pos][0]][0]),dic[pos][1])
            self.check_inventory(pos2)

## CLASSES DERIVEES EXPRES POUR LES BOTS

class LivingBot(Living):

    def __init__(self,terrain,labman,bcx_box=None,specie='loutre',name=None,skin_seq=None):

        super(LivingBot,self).__init__(terrain,labman,bcx_box,specie=specie,name=name,skin_seq=skin_seq)

        self.possible_actions = ['nothing','choice_destination','walk','sleep']
        self.current_main_action = None

        self.choosen_destination = None

    def being_a_bot(self):



        if self.current_main_action == None:
            ## le bot n'a aucune main action en cours
            self.do(choice(self.possible_actions))
        else:
            ## le bot a une main action en cours
            if choice([True]+[False]*99):
                ## mais finalement change d'avis -> permet d'insérer un peu d'aléatoire
                self.current_main_action = None
            else:
                ## fait son action
                self.do(self.current_main_action)


        if self.choosen_destination != None:
            self.labman.add(self.name+' main_acting : ',str(self.current_main_action)+ '   '+str(self.choosen_destination.bcx()))
        else:
            self.labman.add(self.name+' main_acting : ',str(self.current_main_action))

    def do(self,action):

        self.current_action = action
        if self.current_main_action == None:

            if action == 'choice_destination':

                self.choosen_destination = self.terrain.get_random_case(self.pos.lvl())
                self.current_main_action = 'walk'

            elif action == 'walk':
                self.move(choice(self.dirs))

            elif action == 'nothing':
                self.current_main_action = 'nothing'

            elif action == 'sleep':
                self.current_main_action = 'sleep'

        else:
            if action == 'walk':

                dir = []
                xy_pos = tut.from_bcx_to_xy(self.choosen_destination)
                xy_pos2 = tut.from_bcx_to_xy(self.pos)
                vx,vy = tut.xy_add(xy_pos,xy_pos2).xy()
                if vy == 0:
                    self.current_main_action = None
                else:
                    if abs(vx/vy) >= 1:
                        # les x gagnent
                        if vx > 0:
                            dir = [1,0]
                        else:
                            dir = [-1,0]
                    else:
                        # les y gagnent
                        if vy > 0:
                            dir = [0,1]
                        else:
                            dir = [0,-1]

                    self.move(dir)

        #self.labman.add(self.name+' acting : ',self.current_action)



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/positions.py




import src.tile_utils as tut

"""
tout d'abord on défini les positions/sizes relatives, ne
prenant pas en compte la taille de l'ecran
"""


## GENERAL

_a = 1,1
_100x,_100y = 1/19.2 , 1/10.8 # donne 100 pixel par 100 pixel pour du fullhd = 1920x1080
_10x,_10y = 1/192 , 1/108
_1x,_1y = 1/1920 , 1/1080

## POSITIONS

POS_LOADING_bar = 1/2-1/4,1/8

POS_HUD_health_bar = 32*_1x , 32*_1y
POS_HUD_inventory_bar = POS_HUD_health_bar[0] , 18*_10y
POS_HUD_inventory_big = POS_HUD_health_bar[0] , 18*_10y + _100y
POS_HUD_inventory_bar_cursor = POS_HUD_inventory_bar[0] + 19*_1x , POS_HUD_inventory_bar[1] + _10y
POS_HUD_inventory_big_cursor = POS_HUD_inventory_big[0] + 19*_1x , POS_HUD_inventory_big[1] + _10y


## SIZES

SIZ_LOADING_bar = (1/2-POS_LOADING_bar[0])*2,32*_1y

SIZ_HUD_inventory_bar = 502*_1x , 6*_10y
SIZ_HUD_inventory_big = 502*_1x , 5*_100y
SIZ_HUD_inventory_selection = 50*_1x, 50*_1y

"""
maintenant qu'on a defini toutes les positions et tailles relatives,
on les utilise pour créer les BOX, POS,SIZ absolues dont on a besoin dans le programme général,
prenant donc en compte la taille de l'ecran
"""

SIZE_SCREEN = 1920,1080 # default

def box_apply_scr(pos,size):

    return tut.XY_Box(pos[0]*SIZE_SCREEN[0],pos[1]*SIZE_SCREEN[1],size[0]*SIZE_SCREEN[0],size[1]*SIZE_SCREEN[1])

def apply_scr(thg):

    return thg[0]*SIZE_SCREEN[0],thg[1]*SIZE_SCREEN[1]


def update():

    g,b,p,s = {},{},{},{} #boxes , positions, sizes


    ### GENERAL

    g['ax'],g['ay'] = apply_scr(_a)
    g['1x'],g['1y'] = apply_scr((_1x,_1y))
    g['10x'],g['10y'] = apply_scr((_10x,_10y))
    g['100x'],g['100y'] = apply_scr((_100x,_100y))

    ### POSITIONS

    p['loading_bar'] = apply_scr(POS_LOADING_bar)

    p['hud_healthbar'] = apply_scr(POS_HUD_health_bar)
    p['hud_inventory_cursor_bar'] = apply_scr(POS_HUD_inventory_bar_cursor)
    p['hud_inventory_cursor_big'] = apply_scr(POS_HUD_inventory_big_cursor)

    ### BOXES

    s['loading_bar'] = apply_scr(SIZ_LOADING_bar)

    s['hud_inventory_selection'] = apply_scr(SIZ_HUD_inventory_selection)


    #inventaire
    b['hud_inventory'] = [box_apply_scr(POS_HUD_inventory_bar,SIZ_HUD_inventory_bar),
                box_apply_scr(POS_HUD_inventory_big,SIZ_HUD_inventory_big)]

    return g,b,p,s

### BOXES (on utilise les pos et les sizes précedentes)

GEN,BOX,POS,SIZ = update()

def set_size_screen(size):
    global SIZE_SCREEN,GEN,BOX,POS,SIZ
    if size != SIZE_SCREEN:
        SIZE_SCREEN = size
        GEN,BOX,POS,SIZ = update()



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/species.py






dic = {} ## dic regroupant des caractéristiques de chaque espèce (skin seq etc) afin que ça soa pratik qoa



## LOUTRE

if True:

    names = ['Louli','Croquette','Luisante','Marcel','Mamadou','Poisson','Lebleu','Rosetou','Cracante'
        ,'Dodue','Mimi','Moumou','Toumoumou','Limonade','Mimosa','Merlin','Timon','Timéo','Juice','Grenadine','Melon','Legend','IM THE LOUTRE MASTER']

    skin = { 'up':[17,17,17],
        'right':[20,20,20],
        'down':[23,23,23],
        'left':[26,26,26]}

    skills = ['none','normal','walking','swimming']

    dic2 = { 'skin_seq':skin,
            'life':20,
            'names':names,
            'speed':20,
            'skills':skills,
            'size':(32,32)
            }

dic['loutre'] = dic2




## HUMAIN

if True:

    namesg = ['John']*25+['Gabriel','Raphaël','Léo','Louis','Lucas','Adam','Arthur','Jules','Hugo'
    ,'Maël','Liam','Ethan','Paul','Nathan','Gabin','Sacha','Noah','Tom','Mohamed','Aaron'
    ,'Théo','Noé','Victor','Martin','Mathis','Timéo','Nolan','Enzo','Éden','Axel','Antoine','Léon'
    ,'Marius','Robin','Valentin','Clément','Baptiste','Tiago','Rayan','Samuel','Amir','Augustin','Naël'
    ,'Maxime','Maxence','Gaspard','Eliott','Alexandre','Isaac','Mathéo','Yanis','Évan','Simon','Malo','Nino','Marceau','Kylian','Thomas'
    ,'Ibrahim','Imran','Ayden','Lenny','Camille','Lyam','Kaïs','Oscar','Naïm','Sohan','Côme','Milo','Noa','Ilyes','Noam','Diego','Ismaël'
    ,'Léandre','Soan','Mathys','Alexis','Lorenzo','Esteban','Owen','Youssef','Ilyan','William','Adrien','Ayoub','Jean','David','Ali','Adem'
    ,'Wassim','Logan','Sandro','Pablo','Antonin','Joseph','Benjamin','Noham','Kenzo']

    namesf = ['Emma','Jade','Louise','Alice','Chloé','Lina','Léa','Rose','Anna','Mila','Inès','Ambre','Julia','Mia','Léna','Manon','Juliette','Lou','Camille'
    ,'Zoé','Lola','Agathe','Jeanne','Lucie','Éva','Nina','Sarah','Romane','Inaya','Charlotte','Léonie','Romy','Adèle','Iris','Louna','Sofia','Margaux','Luna','Olivia'
    ,'Clémence','Victoria','Léana','Clara','Éléna','Victoire','Aya','Margot','Nour','Giulia','Charlie','Capucine','Mya','Mathilde','Lana','Anaïs','Lilou','Alicia','Théa'
    ,'Gabrielle','Lya','Yasmine','Maëlys','Assia','Apolline','Élise','Alix','Emy','Lise','Elsa','Lily','Lyana','Lisa','Noémie','Marie','Roxane','Lyna','Héloïse','Candice','Valentine'
    ,'Zélie','Maya','Soline','Maria','Célia','Maëlle','Emmy','Éléna','Faustine','Salomé','Lila','Louane','Alya','Thaïs','Constance','Laura','Mélina','Livia','Amelia','Océane','Sara']

    skin = { 'up':[1,2,3],
        'right':[4,5,6],
        'down':[7,8,9],
        'left':[10,11,12]}

    skills = ['none','normal','walking']

    dic2 = {'skin_seq':skin,
            'life':100,
            'names':namesg+namesf,
            'speed':30,
            'skills':skills,
            'size':(32,32)
            }

dic['human'] = dic2



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/terrain.py








import pyglet,random
import src.utils as utils
import src.tile_utils as tut
import src.TerrainCreator as ter

class Biom():

    def __init__(self, ground):

        self.ground = []
        #print(len(ground))
        for i in range(len(ground)):
            self.ground.append(ground[i])

    def set_ground(self,lvl,tab):

        self.ground[lvl] = tab

    def get_case(self,bcx_pos,lvl=None):

        #print('case demandée :')
        if lvl == None:
            lvl = bcx_pos.l
        b,c,x = bcx_pos.bcx()
        return self.ground[lvl][c[1]][c[0]]

    def set_case(self,bcx_pos,val):

        lvl = bcx_pos.l
        b,c,x = bcx_pos.bcx()
        self.ground[lvl][c[1]][c[0]] = val

class TerManager():

    def __init__(self,size,size_biom,name):

        self.name = name
        self.Bioms = []
        self.map = []

        if name != None:

            biom=emptyBiom(size_biom)

            for i in range(size[1]):
                tab = []
                keys = []
                for j in range(size[0]):
                    tab.append(biom)
                    keys.append(0)
                self.Bioms.append(tab)
                self.map.append(keys)

    def set_Biom(self,x,y,biom,key):
        self.Bioms[y][x] = biom
        self.map[y][x] = key

    def get_case(self,bcx_pos,lvl=None):
        b,c,x = bcx_pos.bcx()
        if tut.biom_in_terrain(b):
            return self.Bioms[b[1]][b[0]].get_case(bcx_pos,lvl)
        else:
            return 0

    def set_case(self,bcx_pos,val):
        b,c,x = bcx_pos.bcx()
        self.Bioms[b[1]][b[0]].set_case(bcx_pos,val)

    def verify(self,bcx_pos,key):

        #b,c,x = bcx_pos.bcx() ## par dessus cette case on veut poser key

        if bcx_pos.l == -1:
            return True
        elif bcx_pos.l >= tut.DEPTH_BIOM -1:
            return False
        else:
            oldkey = self.get_case(bcx_pos)

            if ter.REVERSE_DIC[oldkey][1] == 2:
                return True
            elif ter.REVERSE_DIC[oldkey][1] == -1:
                return False
            elif ter.REVERSE_DIC[oldkey][1] == 1:
                return key in ter.REVERSE_DIC[oldkey][2]
            elif ter.REVERSE_DIC[oldkey][1] == 0:
                return not (key in ter.REVERSE_DIC[oldkey][2])

    def get_random_case(self,lvl=utils.choice([i for i in range(tut.DEPTH_BIOM)])):
        b = [random.randint(0,tut.SIZE_TERRAIN[0]-1),random.randint(0,tut.SIZE_TERRAIN[1]-1)]
        c = [random.randint(0,tut.SIZE_BIOM[0]-1),random.randint(0,tut.SIZE_BIOM[1]-1)]
        return tut.BCX_Pos(b,c,l=lvl)


def emptyBiom(biom):

    x = [0]*biom[0]
    tab = [[x]*biom[1]]
    eB = Biom(tab*tut.DEPTH_BIOM)
    return eB



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/TerrainCreator.py







import os
import random
import src.utils as utils
import src.tile_utils as tut
import noise as ns
import perlin.perlin as p



DIC_OF_RULES = { 'water':[ [2], -1 ],
                 'dirt': [ [3,4,7,11,14,17,20,21,23,25,26,27,29,31] , 1,[32,33,34]+[48,49]+[35,36]+[50,51]],
                 'tree': [ [32,33,34] , -1 ],
                 'rock': [ [48,49] , -1 ],
                 'stripped wood': [ [51] , -1 ],
                 'wooden palet': [ [50] , 0, [2] ],
                 'stick': [ [35,36] , -1 ],
                 'empty':[ [0], 2 ]
                 }

## EXEMPLE : 'nom' : [  [differents nombres correspondants au skin de la tile] , valeur de surplombage , rien si valeur de surplombage == -1 ou 2 , tableu de surplombage sinon  ]
## valeur de surplombage:
#           si vaut -1: aucune tile ne sera acceptée par dessus celle là (exemple : eau)
#           si vaut 2: toutes les tiles sont acceptée par dessus (exemple: dirt)
#           si vaut 0: tableau de surplombage est une blacklist
#           si vaut 1: tableau de surplombage est une whitelist
## tableau de surplombage
#           si whitelist: c'est un tableau de toutes les tiles qui sont acceptée par dessus celle là
#           si blacklist: c'est un tableau de toutes les tiles qui sont refusées par dessus celle là (toutes les autres sont acceptées)

WALKTRGH = {'none':[0],
            'normal':[34,48,35,36,51],
            'swimming':[2],
            'being_a_ghost':[3,4,7,11,14,17,20,21,23,25,26,27,29,31,50]
            }

WALKON =   { 'walking':[3,4,7,11,14,17,20,21,23,25,26,27,29,31,50],
             'swimming':[2],
             'flying':[0]
            }

## WALKTRGH WALKON
#       chaque case est affectée à une compétence nécessaire pour marcher au travers et/ou par dessus
#       le perso doit avoir cette compétence (désignée par la specie et ses propres compétences) pour
#       marcher au travers et/ou par dessus



DIC_OF_STYLES = { 'water': 'ground' ,
                 'dirt': 'ground' ,
                 'tree': 'plant' ,
                 'rock': 'plant' ,
                 'stripped wood': 'plant',
                 'stick': 'plant',
                 'wooden palet': 'build',
                 'empty': 'empty'
                 }

REVERSE_DIC = {}
for name in DIC_OF_RULES:
    for x in DIC_OF_RULES[name][0]:
        if DIC_OF_RULES[name][1] == 2 or DIC_OF_RULES[name][1] == -1:
            REVERSE_DIC[x] = [ name , DIC_OF_RULES[name][1] ]
        else:
            REVERSE_DIC[x] = [ name , DIC_OF_RULES[name][1], DIC_OF_RULES[name][2] ]

REVERSE_STYLES = {}
for name in DIC_OF_STYLES:
    if DIC_OF_STYLES[name] not in REVERSE_STYLES:
        REVERSE_STYLES[DIC_OF_STYLES[name]] = [name]
    else:
        REVERSE_STYLES[DIC_OF_STYLES[name]].append(name)

ALL_GROUNDS = []
for name in REVERSE_STYLES['ground']:
    ALL_GROUNDS += DIC_OF_RULES[name][0]

#print('all_ground',ALL_GROUNDS)

ZONES = {'forest':[1,3,4,5,6,7],
        'jungle':[1,3,4,5,6,7],
        'river':[1,3,4,5,6,7],
        'plain':[1]+[i for i in range(3,9)]+[i for i in range(21,32)],
        'mountain':[i for i in range(14,22)],
        'ocean':[2],
        'desert':[25,26,27,10,11,12]
        }

ASSETS = ['forest','stone','palet']

saved_terrains = {}

frequency = 5*tut.SIZE_BIOM[0] , 5*tut.SIZE_BIOM[1]
freq = {}
freq['forest'] = tut.SIZE_BIOM[0] , tut.SIZE_BIOM[1]
freq['stone'] = tut.SIZE_BIOM[0] //2 , tut.SIZE_BIOM[1] //2
freq['palet'] = tut.SIZE_BIOM[0] //2 , tut.SIZE_BIOM[1] //2



# generator de terrains diverses et variés

# Fonction globale creation map

def createMap(size_terrain,size_biom,depth,style=0):

    w,h = size_terrain[0]*size_biom[0],size_terrain[1]*size_biom[1]

    tab_map , tab_land = [],[]

    nb_zones = ((w*h)//8000)+1
    print('nb_zones',nb_zones)

    if style == 0:
        global saved_terrains

        saved_terrains = {}
        color_list = DIC_OF_RULES['dirt'][0]
        for i in color_list:
            saved_terrains[i] = createPlatform(tut.SIZE_BIOM[0],tut.SIZE_BIOM[1],i,depth)

        all_bioms = generate_Biom_colors(*size_terrain)

        for biom in all_bioms:
            print(biom)
        #print(all_bioms)

        w,h = size_terrain

        for j in range(h):
            rangey = []
            rangeymap = []
            for i in range(w):
                choice = all_bioms[j][i]
                biom = modifyPlatform(saved_terrains[choice],(size_biom[0]-1),(size_biom[1]-1))
                rangey.append(biom)
                rangeymap.append(choice)

            tab_land.append(rangey)
            tab_map.append(rangeymap)
    elif style == 1:

        """"""

        print('creating first terrain with noise')
        terrain = create_terrain(nb_zones,size_terrain,size_biom,depth)
        #terrain = modifyPlatform(terrain,w-1,h-1)

        """"""
        terrain[1] = createZone(terrain[1],'stone',w,h)
        """"""
        terrain[1] = createZone(terrain[1],'palet',w,h)
        """"""
        terrain[1] = createZone(terrain[1],'forest',w,h)
        """"""

        terrain = verify(terrain)
        """"""
        print('splitting terrain')
        tab_map , tab_land = from_ter_to_bioms(terrain,size_terrain,size_biom,depth)

        """print('done')
        for y in tab_land[0][0][0]:
            print(y)"""

    return tab_map , tab_land

# Verifieur

def verify(plat):

    depth = len(plat)
    for lvl in range(depth):
        for y in range(len(plat[lvl])):
            for x in range(len(plat[lvl][y])):
                if REVERSE_DIC[plat[lvl][y][x]][1] == -1:
                    for i in range(lvl+1,depth):
                        plat[i][y][x] = 0
                else:
                    if REVERSE_DIC[plat[lvl][y][x]][1] == 0:
                        for i in range(lvl+1,depth):
                            if plat[i][y][x] in REVERSE_DIC[plat[lvl][y][x]][2]:
                                plat[i][y][x] = 0

                    elif REVERSE_DIC[plat[lvl][y][x]][1] == 1:
                        for i in range(lvl+1,depth):
                            if plat[i][y][x] not in REVERSE_DIC[plat[lvl][y][x]][2]:
                                plat[i][y][x] = 0
    return plat


# Fonctions tout-en-un

def createPlatform(w,h,key=1,depth=tut.DEPTH_BIOM):
    # Fonction appelée dans la section load() de l'appli
    # effectuée une seule fois, cela va permettre de sauvegarder la platforme originale

    platform = [ createBlank(0,w,h) for _ in range(depth) ]
    platform[0] = createBlank(key,w,h)
    #platform = addBlank(platform,5,1,1,1,1)
    #print(platform)

    #print(platform)

    return platform

def modifyPlatform(plat,w,h):
    # Fonction appelée dans events()
    # effectuée à chaque fois qu'on appuie sur la touche declencheur
    # permet de recreer une platforme ajoutée à celle originale

    """print(platform)

    for i in range(len(platform)):
        print('lvl',i)
        for y in platform[i]:
            print('     y: ',y)"""

    platform = utils.mycopy(plat)

    platform[1] = addMultForest(platform[1],random.choice(DIC_OF_RULES['tree'][0]))


    platform[0] = addMultForest(platform[0],random.choice(DIC_OF_RULES['water'][0]))
    #platform[0] = addRiver(platform[0],random.choice(DIC_OF_RULES['water'][0]),0,h//2,w,h//2)



    platform = verify(platform)

    return platform

def createZone(savedter,style,w,h,x=0,y=0):

    """
    DOCUMENTATION CREATION DES BIOMES:

    savedter (list) : le terrain de base, qui ne sera pas modifié
    #key (int) : la couleur de dirt considérée
    x,y (int,int) : position du biom généré intégré direct au terrain final
    w,h (int,int) : dimension du biom genéré
    style (str) : decrit le mode de creation du biom

    LISTE DES STYLES:

    forest
    ocean
    mountain
    plain
    river
    jungle
    desert

    FORMAT DU RETOUR:

    terrain (donc [ levels [ casey [ casex ] ] ] )
    avec:
    1 pour de la dirt
    0 pour du vide
    2,3,4.. pour des charactères spéciaux (eau,pierre,mineraux..) #voir DIC_ZONES_CREATION

    """

    tab = utils.mycopy(savedter)

    if style == 'forest':

        #freq = w , h
        keys = [0,0,-1]

        noise = get_diff_noised_list(w,h,len(keys),freq[style],2,3)
        """for n in noise:
            print(n)"""
        for j in range(len(noise)):
            for i in range(len(noise[j])):
                if keys[noise[j][i]] != 0:
                    #print(keys[noise[j][i]],tab[j+y][i+x])
                    try:
                        tab[j+y][i+x] = keys[noise[j][i]]
                        #print(i,j,'good')
                    except:
                        a=0
        ##print('coloring tree')

        v,w=0,0
        for j in range(-y,len(noise)-y):
            for i in range(-x,len(noise[j])-x):
                if tab[j+y][i+x] == -1:
                    #print('lets go pour la',w+1,'e fois','key=',DIC_OF_RULES['tree'][0][v])
                    color(tab,(i,j),DIC_OF_RULES['tree'][0][v])
                    v+=1
                    w+=1
                    if v >= len(DIC_OF_RULES['tree'][0]):
                        v=0

                if tab[j+y][i+x] in DIC_OF_RULES['tree'][0]:
                    if random.choice([False]*20+[True]):
                        tab[j+y][i+x] = random.choice(DIC_OF_RULES['stick'][0])

    if style == 'stone':

        #freq = w , h
        keys = [0,0,0,-1]

        noise = get_diff_noised_list(w,h,len(keys),freq[style],2,3)

        for j in range(len(noise)):
            for i in range(len(noise[j])):
                if keys[noise[j][i]] != 0:
                    try:
                        tab[j+y][i+x] = keys[noise[j][i]]
                    except:
                        a=0
        #print('coloring rock')

        v,w=0,0
        for j in range(-y,len(noise)-y):
            for i in range(-x,len(noise[j])-x):
                if tab[j+y][i+x] == -1:
                    #print('lets go pour la',w+1,'e fois','key=',DIC_OF_RULES['rock'][0][v])
                    color(tab,(i,j),DIC_OF_RULES['rock'][0][v])
                    v+=1
                    w+=1
                    if v >= len(DIC_OF_RULES['rock'][0]):
                        v=0
                if tab[j+y][i+x] == 49:
                    new_pos = [(i+x+1,j+y),(i+x,j+y-1),(i+x-1,j+y),(i+x,j+y+1),(i+x+1,j+y+1),(i+x+1,j+y-1),(i+x-1,j+y-1),(i+x-1,j+y+1)]

                    for k in range(len(new_pos)):
                        x2,y2 = new_pos[k]
                        if y2 >=0 and y2 < len(tab) and x2 >= 0 and x2 < len(tab[y2]):
                            if tab[y2][x2] != 49 and tab[y2][x2] != 48 :
                                tab[y2][x2] = 48

    if style == 'palet':

        #freq = w , h
        keys = [0,0,0,0,-1]

        noise = get_diff_noised_list(w,h,len(keys),freq[style],2,3)

        for j in range(len(noise)):
            for i in range(len(noise[j])):
                if keys[noise[j][i]] != 0:
                    try:
                        tab[j+y][i+x] = keys[noise[j][i]]
                    except:
                        a=0
        #print('coloring palet')

        v,w=0,0
        for j in range(-y,len(noise)-y):
            for i in range(-x,len(noise[j])-x):
                if tab[j+y][i+x] == -1:
                    #print('lets go pour la',w+1,'e fois','key=',DIC_OF_RULES['wooden palet'][0][v])
                    color(tab,(i,j),DIC_OF_RULES['wooden palet'][0][v])
                    v+=1
                    w+=1
                    if v >= len(DIC_OF_RULES['wooden palet'][0]):
                        v=0
                if tab[j+y][i+x] in DIC_OF_RULES['wooden palet'][0] and random.choice([False,False,False,True]) :
                    new_pos = [(i+x+1,j+y),(i+x,j+y-1),(i+x-1,j+y),(i+x,j+y+1),(i+x+1,j+y+1),(i+x+1,j+y-1),(i+x-1,j+y-1),(i+x-1,j+y+1)]
                    for k in range(len(new_pos)):
                        x2,y2 = new_pos[k]
                        if y2 >=0 and y2 < len(tab) and x2 >= 0 and x2 < len(tab[y2]):
                            if tab[y2][x2] not in DIC_OF_RULES['wooden palet'][0]+DIC_OF_RULES['stripped wood'][0]:
                                tab[y2][x2] = random.choice(DIC_OF_RULES['stripped wood'][0])



    return tab


# Fonctions de creation de map

def generate_Biom_colors(w,h):

    bioms = [ [0 for _ in range(w)] for _ in range(h)]

    colored_bioms = {}
    for i in range(random.randint(2,5)):
        biom = random.randint(0,w-1),random.randint(0,h-1)
        colored_bioms[biom] = random.choice(DIC_OF_RULES['dirt'][0])
        bioms[biom[1]][biom[0]] = colored_bioms[biom]

    allColored = False
    while allColored != True:

        nocol = 0
        for j in range(h):
            for i in range(w):
                if bioms[j][i] != 0:

                    for y in [-1,0,1]:
                        for x in [-1,0,1]:
                            if (x,y) != (0,0):
                                try:
                                    if bioms[j+y][i+x] == 0:
                                        index = DIC_OF_RULES['dirt'][0].index(bioms[j][i])+random.randint(-2,2)
                                        if index <= 0:
                                            index += len(DIC_OF_RULES['dirt'][0])
                                        elif index > len(DIC_OF_RULES['dirt'][0]):
                                            index -= len(DIC_OF_RULES['dirt'][0])
                                        bioms[j+y][i+x] = DIC_OF_RULES['dirt'][0][index]
                                except :
                                    a=0
                else:
                    nocol += 1
        allColored = (nocol == 0)
    return bioms

def from_ter_to_bioms(terrain,size_ter=tut.SIZE_TERRAIN,size_biom=tut.SIZE_BIOM,depth=tut.DEPTH_BIOM):

    bioms = []
    map = []
    for j in range(size_ter[1]):
        rangej = []
        mapj = []
        for i in range(size_ter[0]):
            rangei = []
            for lvl in range(depth):
                rangel = []
                for y in range(size_biom[1]):
                    rangey = []
                    for x in range(size_biom[0]):
                        rangey.append( terrain[lvl][ j*size_biom[1] + y ][ i*size_biom[0] + x ] )
                    rangel.append(rangey)
                rangei.append(rangel)
            mapj.append(get_map(rangei))
            rangej.append(rangei)
            #print('biom',i,j,'done')
        map.append(mapj)
        bioms.append(rangej)
    return map,bioms

def get_map(biom):

    occur = {}
    for l in range(len(biom)):
        for y in range(len(biom[l])):
            for x in range(len(biom[l][y])):
                if DIC_OF_STYLES[REVERSE_DIC[biom[l][y][x]][0]] == 'ground':
                    try:
                        occur[biom[l][y][x]] += 1
                    except:
                        occur[biom[l][y][x]] = 1
    maxkey = [0,0]
    for key in occur:
        if occur[key] >= maxkey[1]:
            maxkey = [key,occur[key]]
    return maxkey[0]

def create_terrain(nb_zones,size_ter=tut.SIZE_TERRAIN,size_biom=tut.SIZE_BIOM,depth=tut.DEPTH_BIOM):

    """"""
    w,h = size_ter[0]*size_biom[0] , size_ter[1]*size_biom[1]
    terrain = [ [ [0 for k in range(w)] for q in range(h) ] for _ in range(depth) ]

    #noise = [ [0 for k in range(w)] for q in range(h) ]

    all_grounds = []
    for name in REVERSE_STYLES['ground']:
        all_grounds += DIC_OF_RULES[name][0]

    grounds = []
    if len(all_grounds) > nb_zones:
        for i in range(nb_zones):
            key = random.choice(all_grounds)
            while key in grounds:
                key = random.choice(all_grounds)
            grounds.append(key)
    else:
        grounds = all_grounds
    print('grounds :',grounds)

    """"""

    terrain[0] = get_diff_noised_list(w,h,1,style=2)
    """"""
    #aff(terrain[0])
    #os.system('pause')
    #print('coloring terrain')

    v,w=0,0
    for j in range(len(terrain[0])):
        for i in range(len(terrain[0][j])):
            if terrain[0][j][i] == -1:
                #print('lets go pour la',w+1,'e fois','key=',grounds[v])
                color(terrain[0],(i,j),grounds[v])
                v+=1
                w+=1
                if v >= len(grounds):
                    v=0
            elif terrain[0][j][i] == 0:
                terrain[0][j][i] = 2

    return terrain

    #zones = [ random.choice(all_bioms) for _ in range(nb_zones) ]


# noise

def get_noised_list(w,h,nb):

    ter = [ [0 for _ in range(w)] for _ in range(h)]
    random.seed()
    z=random.random()
    octaves = random.random()
    freq = 16.0 * octaves
    for y in range(h):
        for x in range(w):
            #ter[y][x] = ns.pnoise2(x/freq, y / freq, 1)
            ter[y][x] = int(((ns.pnoise3(x/freq, y / freq,0.1, repeatx=1024, repeaty=1024, repeatz=1024)+1)/2) // (1/nb) )
            if ter[y][x] == nb:
                ter[y][x] = nb-1
            """if ter[y][x]>=1:
                ter[y][x]=1
            else:
                ter[y][x]=0"""
    """for y in ter:
        print(y)"""
    return ter

def get_diff_noised_list(w,h,nb,f=frequency,oct=4,style=1):

    tab = []

    manager = p.PerlinNoiseFactory(2,oct)

    for j in range(h):
        tabj = []
        u = []
        for i in range(w):
            noise = manager(float(i/f[0]),float(j/f[1]))
            u.append(utils.truncate(noise,3))

            if style == 1:
                tabj.append( int((noise // (1/nb) ) ))

            elif style == 2:

                if abs(noise) < 0.01*nb:
                    noise = 0
                else:
                    noise = -1
                """mid = nb//2
                noise2 =  int(((noise+1)/2) // (1/nb) )
                #print(mid,noise2)
                if noise2 != mid:
                    noise2 = -1
                else:
                    noise2 = 0"""
                tabj.append(noise)

            elif style == 3:
                tabj.append( int(((noise+1)/2) // (1/nb) ) )

        tab.append(tabj)
        #print(u)
    """for y in tab:
        print(y)"""
    return tab


def is_full(ter,pos,key,old=-1,style=1):

    x,y = pos
    if style==1:
        new_pos = [(x+1,y),(x,y-1),(x-1,y),(x,y+1)]
    else:
        new_pos = [(x+1,y),(x,y-1),(x-1,y),(x,y+1),(x+1,y+1),(x+1,y-1),(x-1,y-1),(x-1,y+1)]

    fulled = True
    #keys = [0,-2,key]

    for i in range(len(new_pos)):
        x,y = new_pos[i]
        if y >=0 and y < len(ter) and x >= 0 and x < len(ter[y]):
            if ter[y][x] == old:
                #if not ter[y][x] in keys:
                return False
    return True

def color(ter,pos,key,old=-1,style=1):

    """

    JE PENSE QU'ON PEUT AMELIORER CETTE FONCTION

    """

    x,y = pos
    tab = [(x,y)]
    ter[y][x] = -2

    good = False

    while not good:
        #print(x,y)
        #aff(ter)

        if style==1:
            new_pos = [(x+1,y),(x,y-1),(x-1,y),(x,y+1),(x,y)]
        else:
            new_pos = [(x+1,y),(x,y-1),(x-1,y),(x,y+1),(x+1,y+1),(x+1,y-1),(x-1,y-1),(x-1,y+1),(x,y)]

        added = False
        for i in range(len(new_pos)):
            x,y = new_pos[i]
            if y >=0 and y < len(ter) and x >= 0 and x < len(ter[y]):
                if ter[y][x] == old and not added:
                    ter[y][x] = -2
                    tab.append(new_pos[i])
                    added = True
                if ter[y][x] == -2 and is_full(ter,new_pos[i],key,old):
                    ter[y][x] = key
                    if (x,y) in tab:
                        tab.remove((x,y))

        try:
            x,y = tab[-1]
        except:
            good=True

# Fonctions premieres

def createBlank(key,weight,height):
    terrain = []

    for i in range(height):
        line = []
        for j in range(weight):
            line.append(key)
        terrain.append(line)
    #print(terrain)

    return terrain

def addBlank(savedter,key,weight,height,x,y):

    terrain = utils.mycopy(savedter)

    for i in range(len(terrain)):
        for j in range(len(terrain[0])):
            if j>=x and  j<x+weight and i>=y and i<y+height:
                terrain[i][j] = key
    return terrain

def addForest(savedter,key,w,h,x,y,dt=random.randint(2,4),dtlinear=2):
    # dt determine le nombre de rectangles de foret créé
    # dtlinear determine la facon dont sera créée la foret :
    #       plus dtlinear est petit, plus les rectangles seront linéaires

    #terrain = addBlank(terrain,0,w,h,x,y)

    terrain = utils.mycopy(savedter)

    for k in range(dt):
        x_forest = random.randint(x,x+w-1-dtlinear)
        y_forest = random.randint(y,y+h-1-dtlinear)
        #terrain = addBlank(terrain,9,w-(x_forest-x),h-(y_forest-y),x_forest,y_forest)

        w_forest = random.randint(1+dtlinear,w-(x_forest-x))
        h_forest = random.randint(1+dtlinear,h-(y_forest-y))

        terrain = addBlank(terrain,key,w_forest,h_forest,x_forest,y_forest)

    return terrain

def addMultForest(savedter,key):

    #print(savedter)
    terrain = utils.mycopy(savedter)

    #for y in terrain:
    #    print('     y: ',y)

    w_blank = len(terrain[0])
    h_blank = len(terrain)

    if w_blank//10 > 2:
        delta_w = w_blank//10
    elif w_blank//10 == 0:
        return terrain
    else:
        delta_w = 3

    if h_blank//10 > 2:
        delta_h = h_blank//10
    elif h_blank//10 == 0:
        return terrain
    else:
        delta_h = 3


    nb_forest = random.randint(1,w_blank//10 + h_blank//10)

    #print(w_blank,h_blank,nb_forest)

    for i in range(nb_forest):
        x=random.randint(0,w_blank-delta_w)
        y=random.randint(0,h_blank-delta_h)

        w = random.randint(delta_w,w_blank-x)
        h = random.randint(delta_h,h_blank-y)
        #print(x,y,w,h)

        terrain = addForest(terrain,key,w,h,x,y)

    return terrain

def addRiver(savedter,key,x_dep,y_dep,x_ar,y_ar):


    terrain = utils.mycopy(savedter)

    #terrain = addBlank(terrain,5,x_ar-x_dep+1,y_ar-y_dep+1,x_dep,y_dep)

    points = [[x_dep,y_dep]]
    nbx,nby = (x_ar-x_dep)//10-1 , (y_ar-y_dep)//20-1
    if nbx < 0:
        nbx = 0
    if nby < 0:
        nby = 0
    x_dabord = nbx >= nby
    ix,iy = 0,0

    #print(x_dabord,nbx,nby)

    while not ( nbx == 0 and nby == 0 ):
        if x_dabord:
            if nbx > 0:
                y = random.randint(-5,5)
                points.append([x_dep+(ix+1)*10,(y_ar+y_dep)//2+y])
                ix+=1
                nbx-=1
                #print(nbx,nby,points)
            x_dabord = False
        else:
            if nby > 0:
                x = random.randint(-5,5)
                points.append([y_dep+(iy+1)*20,(x_ar+x_dep)//2+x])
                iy+=1
                nby-=1
                #print(nbx,nby,points)
            x_dabord = True
    """
    for i in range((x_ar-x_dep)//10-1):
        y = random.randint(-5,5)
        points.append([x_dep+(i+1)*10,(y_ar-y_dep//2)+y])
        """
    points.append([x_ar,y_ar])

    #print(points)

    path = []

    for i in range(len(points)-1):
        path += drawPath(points[i][0],points[i][1],points[i+1][0],points[i+1][1])

    for i in range(len(terrain)):
        for j in range(len(terrain[0])):
            if [j,i] in path:
                terrain[i][j] = key

    return terrain

def drawPath(xd,yd,xa,ya):
    path = [[xd,yd]]
    nb_x,nb_y = xa - xd, ya - yd

    x,y = xd,yd

    while x != xa or y != ya:
        if nb_x !=0 and nb_y !=0:
            x_ou_y = random.randint(0,1)
            if x_ou_y:
                if nb_x > 0:
                    x+=1
                    nb_x -= 1
                else:
                    x-=1
                    nb_x += 1
            else:
                if nb_y >0:
                    y+=1
                    nb_y -= 1
                else:
                    y-=1
                    nb_y += 1
        elif nb_x ==0:
            if nb_y >0:
                y+=1
                nb_y -= 1
            else:
                y-=1
                nb_y += 1
        else:
            if nb_x > 0:
                x+=1
                nb_x -= 1
            else:
                x-=1
                nb_x += 1
        path.append([x,y])

    return path


## UTILS


def aff(ter):

    for y in ter:
        to_p = ''
        for w in y:

            if w == 0:
                x = ' '
            else:
                x = '*'

            """if type(x) != type(' '):
                a = str(x)
            else:
                a = x
            b = ''
            for i in range(2-len(a)):
                b+=' '"""
            to_p+=(x)
        print(to_p)



 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/test2.py








import pyglet,graphic,utils,terrain,test2,perso,drawable
import time,os
from TerrainCreator import *
from pyglet.window import key

class App(pyglet.window.Window):


    ### INIT FUNCTIONS

    def __init__(self):

        super(App, self).__init__()

        self.size_scr = 1000,800
        self.set_size(self.size_scr[0],self.size_scr[1])
        self.current_size_scr = self.size_scr

        self.manager = graphic.MainManager()
        self.specMan = graphic.SpecialManager(self.manager,self.current_size_scr)


        # loading fonts
        font_path = 'item/fonts/'
        self.font = ['starguard','starguardhalf']
        for ft in self.font:
            try:
                pyglet.resource.add_font(font_path+ft+'.otf')
                print(ft,'done')
            except:
                pyglet.resource.add_font(font_path+ft+'.ttf')
                print(ft,'ttf done')
        self.font = ['Star Guard','Star Guard Halftone']

        self.size_tile = 32 # en px

        self.textids = {}

        self.sprids = {}
        self.sprids['menu'] = {}


    def init(self):

        #self.nb=0
        self.keys = key.KeyStateHandler()
        self.push_handlers(self.keys)

        self.playing = True
        self.actions = ['menu','showing','nothing']
        self.action = 0

        self.init_menu()

        pyglet.clock.schedule_interval(self.gameloop,0.0000001)
        pyglet.app.run()

    def init_menu(self):

        self.sprids['menu']['play_btn'] = self.specMan.addThg(drawable.LabelButton(self.bite,(300,100),'PLAY',
                                                            (self.font[0],self.font[0]),
                                                            96,
                                                            self.current_size_scr[0]//2,
                                                            self.current_size_scr[1]//2 +100,color=(255,255,255,255)),'play_btn')
        self.buttons = {}

        self.buttons[0] = ['play_btn']

        self.action_menu = 0

    def on_key_press(self,symbol,modifiers):

        if symbol == key.ESCAPE:
            self.close()
        elif symbol == key.RETURN:
            self.bite()
    """
    def on_mouse_motion(self,x,y,dx,dy):

        if self.actions[self.action] == 'menu':
            for name in self.buttons[self.action_menu]:
                if x+dx > self.specMan.to_draw[name][0].x - self.specMan.to_draw[name][0].box[0] and x+dx < self.specMan.to_draw[name][0].x + self.specMan.to_draw[name][0].box[0] and y+dy > self.specMan.to_draw[name][0].y - self.specMan.to_draw[name][0].box[1] and y+dy < self.specMan.to_draw[name][0].y + self.specMan.to_draw[name][0].box[1]:
                    self.specMan.to_draw[name][0].the_mouse_is_here()
                else:
                    self.specMan.to_draw[name][0].the_mouse_is_not_here_anymore()
                #elif x > self.specMan.to_draw[name][0].x - self.specMan.to_draw[name][0].box[0] and x < self.specMan.to_draw[name][0].x + self.specMan.to_draw[name][0].box[0] and y > self.specMan.to_draw[name][0].y - self.specMan.to_draw[name][0].box[1] and y < self.specMan.to_draw[name][0].y + self.specMan.to_draw[name][0].box[1]:
                    #self.specMan.to_draw[name][0].the_mouse_is_not_here_anymore()

    def on_mouse_press(self,x, y, button, modifiers):

        if self.actions[self.action] == 'menu':
            for name in self.buttons[self.action_menu]:
                if self.specMan.to_draw[name][0].here:
                    self.specMan.to_draw[name][0].i_am_pressed()

    def on_mouse_release(self,x, y, button, modifiers):

        if self.actions[self.action] == 'menu':
            for name in self.buttons[self.action_menu]:
                if self.specMan.to_draw[name][0].pressed:
                    self.specMan.to_draw[name][0].i_am_released()
    """

    def bite(self):

        print('pd')
        img = pyglet.image.load('item/fond.png')
        img.blit(0,0)
        self.flip()
        os.system('pause')
    """
    def draw(self):

        if self.actions[self.action] == 'pd' or self.actions[self.action] == 'menu':


            if self.actions[self.action] == 'menu':

                if self.action_menu == 0:
                    self.specMan.draw(['play_btn'])
    """
    def gameloop(self,dt):

        if self.playing:

            ### CLEAR
            #self.clear()
            a=0

        else:
            self.close()


def main():

    app = App()
    app.init()

if __name__ == '__main__':
    main()












 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/tile_utils.py








import math

## definitions de fonctions et classes utiles pour le tilemapping

### VARIABLES

SIZE_TERRAIN = 4,4
SIZE_BIOM = 32,32
SIZE_TILE = 32,32

DEPTH_BIOM = 3

Y_DEP = (SIZE_BIOM[1]-1)*SIZE_TILE[1]
Y_DEP_BIOM = (SIZE_TERRAIN[1]-1)*SIZE_BIOM[1]*SIZE_TILE[1]

def set_var(ter,biom,tile=(32,32)):

    global SIZE_TERRAIN,SIZE_BIOM,SIZE_TILE,Y_DEP,Y_DEP_BIOM

    SIZE_TERRAIN = ter[0],ter[1]
    SIZE_BIOM = biom[0],biom[1]
    SIZE_TILE = tile[0],tile[1]

    Y_DEP = (SIZE_BIOM[1]-1)*SIZE_TILE[1]
    Y_DEP_BIOM = (SIZE_TERRAIN[1]-1)*SIZE_BIOM[1]*SIZE_TILE[1]


### CLASSES

class XY_Pos():

    def __init__(self,x=0,y=0):
        self.x = x
        self.y = y

    def xy(self):
        return self.x,self.y

    def __repr__(self):
        return "XY_Pos : x= %s, y= %s" % (self.x, self.y)
    def __str__(self):
        return "XY_Pos : x= %s, y= %s" % (self.x, self.y)

class BCX_Pos():

    def __init__(self,b=(0,0),c=(0,0),p=(0,0),l=0):

        #if b==(0,0) and c==(0,0) and p==(0,0):
        #print('connar')
        self.x = [b[0],c[0],p[0]]
        self.y = [b[1],c[1],p[1]]
        self.l = l
        #print(self)

    def bcx(self):
        return (self.x[0],self.y[0]),(self.x[1],self.y[1]),(self.x[2],self.y[2])

    def ijxy(self):
        return self.x[0],self.y[0],self.x[1],self.y[1]

    def lvl(self):
        return self.l

    def __repr__(self):
        return "BCX_Pos : x= %s, y= %s, l= %s" % (self.x, self.y,self.l)
    def __str__(self):
        return "BCX_Pos : x= %s, y= %s, l= %s" % (self.x, self.y,self.l)
    """def __sub__(self,pos):

        pos = pos.bcx()
        self.x[0]-= pos[0][0]
        self.x[1]-= pos[1][0]
        self.x[2]-= pos[2][0]
        self.x[0]-= pos[0][1]
        self.x[1]-= pos[1][1]
        self.x[2]-= pos[2][1]
        return BCX_Vec(*self.bcx())"""

class XY_Vec():

    def __init__(self,x=0,y=0):
        self.x = x
        self.y = y

    def xy(self):
        return self.x,self.y

    def __repr__(self):
        return "XY_Vec : x= %s, y= %s" % (self.x, self.y)
    def __str__(self):
        return "XY_Vec : x= %s, y= %s" % (self.x, self.y)

class BCX_Vec():

    def __init__(self,b=(0,0),c=(0,0),p=(0,0)):

        #if b==(0,0) and c==(0,0) and p==(0,0):
        #print('connar')
        self.x = [b[0],c[0],p[0]]
        self.y = [b[1],c[1],p[1]]
        #print(self)

    def bcx(self):
        return (self.x[0],self.y[0]),(self.x[1],self.y[1]),(self.x[2],self.y[2])

    def ijxy(self):
        return self.x[0],self.y[0],self.x[1],self.y[1]

    def __repr__(self):
        return "BCX_Vec : x= %s, y= %s" % (self.x, self.y)
    def __str__(self):
        return "BCX_Vec : x= %s, y= %s" % (self.x, self.y)

class XY_Size():

    def __init__(self,w=0,h=0):
        self.w = w
        self.h = h

    def xy(self):
        return self.w,self.h

    def __repr__(self):
        return "XY_Size : w= %s, h= %s" % (self.w, self.h)
    def __str__(self):
        return "XY_Size : w= %s, h= %s" % (self.w, self.h)

class BCX_Size():

    def __init__(self,b=(0,0),c=(0,0),p=(0,0)):
        self.w = [b[0],c[0],p[0]]
        self.h = [b[1],c[1],p[1]]

    def bcx(self):
        return (self.w[0],self.h[0]),(self.w[1],self.h[1]),(self.w[2],self.h[2])

    def ijxy(self):
        return self.w[0],self.h[0],self.w[1],self.h[1]

    def __repr__(self):
        return "BCX_Size : w= %s, h= %s" % (self.w, self.h)
    def __str__(self):
        return "BCX_Size : w= %s, h= %s" % (self.w, self.h)

class XY_Box():

    def __init__(self,x,y,w,h):
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def pos(self):
        return self.x,self.y
    def size(self):
        return self.w,self.h

    def Pos(self):
        return XY_Pos(self.x,self.y)
    def Size(self):
        return XY_Size(self.w,self.h)

    def __repr__(self):
        return "XY_Box : x= %s, y= %s, w= %s, h= %s" % (self.x, self.y,self.w, self.h)
    def __str__(self):
        return "XY_Box : x= %s, y= %s, w= %s, h= %s" % (self.x, self.y,self.w, self.h)

class BCX_Box():

    def __init__(self,b1=[0,0],c1=[0,0],p1=[0,0],l=0,b2=[0,0],c2=[0,0],p2=[0,0]):
        self.x = [b1[0],c1[0],p1[0]]
        self.y = [b1[1],c1[1],p1[1]]
        self.w = [b2[0],c2[0],p2[0]]
        self.h = [b2[1],c2[1],p2[1]]
        self.l = l

    def pos(self):
        return (self.x[0],self.y[0]),(self.x[1],self.y[1]),(self.x[2],self.y[2]),self.l
    def size(self):
        return (self.w[0],self.h[0]),(self.w[1],self.h[1]),(self.w[2],self.h[2])

    def Pos(self):
        return BCX_Pos((self.x[0],self.y[0]),(self.x[1],self.y[1]),(self.x[2],self.y[2]),self.l)
    def Size(self):
        return BCX_Size((self.w[0],self.h[0]),(self.w[1],self.h[1]),(self.w[2],self.h[2]))


    def __repr__(self):
        return "BCX_Box : x= %s, y= %s, l=%s, w= %s, h= %s" % (self.x, self.y,self.l,self.w, self.h)
    def __str__(self):
        return "BCX_Box : x= %s, y= %s, l=%s, w= %s, h= %s" % (self.x, self.y,self.l,self.w, self.h)


### CAMERAS

class Cam():

    def __init__(self,name,center=XY_Vec(),speed=1,scale=1):

        self.name = name
        self.center = XY_Vec(center.x,center.y)
        self.speed = speed #inversé, plus c'est petit, plus la camera bouge rapidement et de manière saccadée. privilegier 6 ou 8

        self.pos = XY_Vec(center.x,center.y)
        self.obj = XY_Vec(center.x,center.y)

    def update(self):

        #vec = xy_add(self.obj,self.pos)

        dx = - self.pos.x + self.obj.x
        dy = - self.pos.y + self.obj.y

        if abs(dx/self.speed) > 1:
            dx = dx//self.speed
        if abs(dy/self.speed) > 1:
            dy = dy//self.speed

        self.pos.x += dx
        self.pos.y += dy
        #self.pos = xy_add(self.pos,vec)

    def move(self,xy_vec):

        #print(self.pos)
        self.pos = xy_add(self.pos,xy_vec,-1)
        #print(self.pos)

    def xy(self):
        return self.center.x-self.pos.x,self.center.y-self.pos.y

CAMERA = Cam('cam')
ADMIN_CAM = Cam('admin')

def get_cam(xy_pos,speed):
    return Cam(CAMERA.name,xy_pos,speed),Cam(ADMIN_CAM.name)

def set_cam(cam,admin):
    global CAMERA,ADMIN_CAM
    CAMERA = cam
    ADMIN_CAM = admin


### FUNCTIONS

# useful

def module_XY(xy_vec):

    return math.sqrt( (xy_vec.x)**2 + (xy_vec.y)**2 )

def biom_in_terrain(b):
    if (b[0]>=0 and b[0]<SIZE_TERRAIN[0]) and (b[1]>=0 and b[1]<SIZE_TERRAIN[1]):
        return True
    else:
        #print(b,'not in terrain !')
        return False

def get_pos_map_biom(b,scr_size):
    i,j = b
    return (i*SIZE_TILE[0] + scr_size[0]//2 - (SIZE_TERRAIN[0]*SIZE_TILE[0])//2,-(j+1)*SIZE_TILE[0] + scr_size[1]//2 + (SIZE_TERRAIN[1]*SIZE_TILE[0])//2)

# conversions

def from_bcx_to_pxx(b,c):

    i,j = b
    x,y = c
    posx = ADMIN_CAM.center.x-ADMIN_CAM.pos.x + CAMERA.center.x-CAMERA.pos.x +SIZE_TILE[0]*x + i*SIZE_BIOM[0]*SIZE_TILE[0]
    posy = ADMIN_CAM.center.x-ADMIN_CAM.pos.y + CAMERA.center.y-CAMERA.pos.y +Y_DEP - SIZE_TILE[0]*y + Y_DEP_BIOM - j*SIZE_BIOM[1]*SIZE_TILE[0]

    return posx,posy

def from_pxpos_to_realpos(pxpos,admin=True):

    #print(CAMERA.xy().x + pxpos.x)
    x_on_scr = CAMERA.xy()[0] + pxpos.x
    y_on_scr = CAMERA.xy()[1] + pxpos.y

    if admin:
        x_on_scr += ADMIN_CAM.pos.x
        y_on_scr += ADMIN_CAM.pos.y

    return XY_Pos(x_on_scr,y_on_scr)

def from_real_to_pxpos(realpos,admin=True):

    pxx = -CAMERA.xy()[0] + realpos.x
    pxy = -CAMERA.xy()[1] + realpos.y

    if admin:
        pxx -= ADMIN_CAM.pos.x
        pxy -= ADMIN_CAM.pos.y

    return XY_Pos(pxx,pxy)


def from_xy_to_bcx(xy_thg,l=0):

    if type(xy_thg) == XY_Pos:

        bx = xy_thg.x//(SIZE_BIOM[0]*SIZE_TILE[0])
        cx = (xy_thg.x%(SIZE_BIOM[0]*SIZE_TILE[0]))//SIZE_TILE[0]
        px = (xy_thg.x%(SIZE_BIOM[0]*SIZE_TILE[0]))%SIZE_TILE[0]

        y = xy_thg.y - Y_DEP - Y_DEP_BIOM
        py = (y%(SIZE_BIOM[1]*SIZE_TILE[1]))%(SIZE_TILE[1])

        y = - xy_thg.y + Y_DEP + Y_DEP_BIOM + py

        by = y//(SIZE_BIOM[1]*SIZE_TILE[1])
        cy = (y%(SIZE_BIOM[1]*SIZE_TILE[1]))//(SIZE_TILE[1])

        return BCX_Pos((bx,by),(cx,cy),(px,py),l)

    elif type(xy_thg) == XY_Vec:

        bx = xy_thg.x//(SIZE_BIOM[0]*SIZE_TILE[0])
        cx = (xy_thg.x%(SIZE_BIOM[0]*SIZE_TILE[0]))//SIZE_TILE[0]
        px = (xy_thg.x%(SIZE_BIOM[0]*SIZE_TILE[0]))%SIZE_TILE[0]

        by = xy_thg.y//(SIZE_BIOM[1]*SIZE_TILE[1])
        cy = (xy_thg.y%(SIZE_BIOM[1]*SIZE_TILE[1]))//SIZE_TILE[1]
        py = (xy_thg.y%(SIZE_BIOM[1]*SIZE_TILE[1]))%SIZE_TILE[1]

        return BCX_Vec((bx,by),(cx,cy),(px,py))

    elif type(xy_thg) == XY_Size:

        bw = xy_thg.w//(SIZE_BIOM[0]*SIZE_TILE[0])
        cw = (xy_thg.w%(SIZE_BIOM[0]*SIZE_TILE[0]))//SIZE_TILE[0]
        pw = (xy_thg.w%(SIZE_BIOM[0]*SIZE_TILE[0]))%SIZE_TILE[0]

        bh = xy_thg.h//(SIZE_BIOM[1]*SIZE_TILE[1])
        ch = (xy_thg.h%(SIZE_BIOM[1]*SIZE_TILE[1]))//SIZE_TILE[1]
        ph = (xy_thg.h%(SIZE_BIOM[1]*SIZE_TILE[1]))%SIZE_TILE[1]

        return BCX_Pos((bw,bh),(cw,ch),(pw,ph))

    elif type(bcx_thg) == XY_Box:

        pos = from_xy_to_bcx(XY_Pos(bcx_thg.x,bcx_thg.y))
        size = from_xy_to_bcx(XY_Size(bcx_thg.w,bcx_thg.h))

        return BCX_Box(*pos.bcx(),l,*size.bcx())

def from_bcx_to_xy(bcx_thg):

    if type(bcx_thg) == BCX_Pos:

        px = SIZE_TILE[0]*SIZE_BIOM[0]*bcx_thg.x[0] + SIZE_TILE[0]*bcx_thg.x[1] + bcx_thg.x[2]
        py = Y_DEP + Y_DEP_BIOM - SIZE_TILE[1]*SIZE_BIOM[1]*bcx_thg.y[0] - SIZE_TILE[1]*bcx_thg.y[1] + bcx_thg.y[2]

        return XY_Pos(px,py)

    elif type(bcx_thg) == BCX_Vec:

        px = SIZE_TILE[0]*SIZE_BIOM[0]*bcx_thg.x[0] + SIZE_TILE[0]*bcx_thg.x[1] + bcx_thg.x[2]
        py = SIZE_TILE[1]*SIZE_BIOM[1]*bcx_thg.y[0] + SIZE_TILE[1]*bcx_thg.y[1] + bcx_thg.y[2]

        return XY_Vec(px,py)

    elif type(bcx_thg) == BCX_Size:

        wx = SIZE_TILE[0]*SIZE_BIOM[0]*bcx_thg.w[0] + SIZE_TILE[0]*bcx_thg.w[1] + bcx_thg.w[2]
        wy = SIZE_TILE[1]*SIZE_BIOM[1]*bcx_thg.h[0] + SIZE_TILE[1]*bcx_thg.h[1] + bcx_thg.h[2]

        return XY_Size(wx,wy)

    elif type(bcx_thg) == BCX_Box:

        x,y = from_bcx_to_xy(BCX_Pos((bcx_thg.x[0],bcx_thg.y[0]),(bcx_thg.x[1],bcx_thg.y[1]),(bcx_thg.x[2],bcx_thg.y[2]))).xy()
        w,h = from_bcx_to_xy(BCX_Size((bcx_thg.w[0],bcx_thg.h[0]),(bcx_thg.w[1],bcx_thg.h[1]),(bcx_thg.w[2],bcx_thg.h[2]))).xy()

        return XY_Box(x,y,w,h)


# additions

def bcx_add(bcx_thg,bcx_vec):

    l = bcx_thg.l
    xy_thg = from_bcx_to_xy(bcx_thg)
    xy_vec = from_bcx_to_xy(bcx_vec)
    return from_xy_to_bcx(xy_add(xy_thg,xy_vec),l)

def xy_add(xy_thg,xy_vec, k=1):

    xy_thg.x = xy_thg.x +k*xy_vec.x
    xy_thg.y = xy_thg.y +k*xy_vec.y

    return xy_thg


# algo collisions

def algo_colli_BCX(init_bcx_box,bcx_vec,colli_bcx_box):

    init_xy_box = from_bcx_to_xy(init_bcx_box)
    xy_vec = from_bcx_to_xy(bcx_vec)
    colli_xy_box = from_bcx_to_xy(colli_bcx_box)
    return algo_colli_XY(init_xy_box,xy_vec,colli_xy_box)

def algo_colli_XY(init_xy_box,xy_vec,colli_xy_box):

    box1 = XY_Box(init_xy_box.x,init_xy_box.y,init_xy_box.w,init_xy_box.h)
    box1.x += xy_vec.x
    box1.y += xy_vec.y
    return colli_AABB_XY(box1,colli_xy_box)

def colli_AABB_XY(box1,box2): #EST-CE QUE CA COLLISIONNE BIEN PAS ?

    if ((box2.x >= box1.x + box1.w) or (box2.x + box2.w <= box1.x) or (box2.y >= box1.y + box1.h) or (box2.y + box2.h <= box1.y)):
        return True # retourne un okaaayyyy c'est bon ca collisionne PAS
    else:
        return False # aoutch ca collisionne

def colli_ABP_XY(box,pt): #EST-CE QUE LE POINT EST BIEN DANS LA BOX ?

    if type(pt) == XY_Pos:
        if (pt.x >= box.x) and (pt.x < box.x + box.w) and (pt.y >= box.y) and (pt.y < box.y + box.h):
            return True # okaaayyyy t'es bien dans la boite mon pti
        else:
            return False # retourne un ouai bah non t pas dedans
    else:
        if (pt[0] >= box.x) and (pt[0] < box.x + box.w) and (pt[1] >= box.y) and (pt[1] < box.y + box.h):
            return True # okaaayyyy t'es bien dans la boite mon pti
        else:
            return False # retourne un ouai bah non t pas dedans

def colli_ABP(box,pt):
    x,y,w,h = box
    if (pt[0] >= x) and (pt[0] < x + w) and (pt[1] >= y) and (pt[1] < y + h):
        return True # okaaayyyy t'es bien dans la boite mon pti
    else:
        return False # retourne un ouai bah non t pas dedans

def colli_ABP_mult(boxes,pt):
    ## retourne None si le point est dans aucune boite
    ## retourne la premiere box des boites concernées sinon

    goodx = []
    goody = []

    ## Premier niveau -> on vérifie si on est pas à gauche de toutes les box
    for i in range(len(boxes)):
        if pt[0] >= boxes[i][0]:
            goodx.append(i)
    if goodx == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    ## 2e niveau -> on vérifie si on est pas en dessous des box qui sont bien
    for i in goodx:
        if pt[1] >= boxes[i][1]:
            goody.append(i)
    if goody == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    ## 3e niveau -> on vérifie si on est pas à droite des box qui sont bien
    goodx = []
    for i in goody:
        if pt[0] < boxes[i][0] + boxes[i][2]:
            goodx.append(i)
    if goodx == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    ## 4e niveau -> on vérifie si on est pas en haut des box qui sont bien
    goody = []
    for i in goodx:
        if pt[1] < boxes[i][1] + boxes[i][3]:
            goody.append(i)
    if goody == []:
        return None # retourne un ouai bah t'es dans rien mon pote

    return goody[0]






 _newfile_ :Z:\DESKTOP\CODING\delta2d/src/utils.py






import random,os,ctypes,time
from ctypes import windll, Structure, c_long, byref
from math import *
#from win32gui import GetWindowRect, GetForegroundWindow, GetWindowText


class POINT(Structure):
    _fields_ = [("x", c_long), ("y", c_long)]

## partie SCREEN

def get_screen_size():
    user32 = ctypes.windll.user32
    return user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)


## partie random

def choice(thg):

    if type(thg) == type({}):
        return choice(list(thg.keys()))
        #print(thg.keys())
    else:
        return random.choice(thg)

def randmultint(n,a,b=None): #returns n differents numbers between a and b-1

    if b == None:
        return randmultint(n,0,a-1)
    else:
        t = []
        while len(t) < n:
            new = random.randint(a,b-1)
            while new in t:
                new = random.randint(a,b-1)
            t.append(new)
        return t


def get_key_from_value(d,v,s=[]): # v valeur seule, d dic ou tab

    if type(d) == type({}):
        for key,val in d.items():
            if type(val) != type({}) and type(val) != type([]):
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    elif type(d) == type([]):
        for key in range(len(d)):
            val = d[key]
            if type(val) != type({}) and type(val) != type([]):
                #print(val)
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    return None

def getMousePos():
    pt = POINT()
    windll.user32.GetCursorPos(byref(pt))
    return pt.x,pt.y

def module(x,y):
    return sqrt(x**2+y**2)

def int_rd(dec):
    if dec < int(dec)+0.5:
        return int(dec)
    else:
        return ceil(dec)

def sign(n):
    if n==0:
        return 0
    else:
        return n//abs(n)

def rangef(a,b,d=1):

    res = []
    if b > a:
        while b>a:
            res.append(a)
            a+=d
    else:
        while abs(b-a)>0:
            res.append(a)
            a+=d

    return res

ids = 1112

def get_id(key):

    global ids

    id = ''+key
    id+=str(ids)
    ids+=1
    return id

def mycopy(thg):

    if type(thg) == type([]):

        res = []

        for i in thg:
            res.append(mycopy(i))

        return res

    else:

        return thg

def truncate(f, n=3):
    '''Truncates/pads a float f to n decimal places without rounding'''
    s = '{}'.format(f)
    if 'e' in s or 'E' in s:
        return '{0:.{1}f}'.format(f, n)
    i, p, d = s.partition('.')
    return '.'.join([i, (d+'0'*n)[:n]])

### PARTIE AUTO-SAUVEGARDE
"""
def save_files(bigpath,path = ['/.','/src'],save_path = '/autosav/'):

    autosav = ''

    for chem in path:
        #print('path',bigpath+chem,':',os.listdir(bigpath+chem))
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    autosav += '\n\n\n _newfile_ :' + bigpath+chem+'/'+file + '\n\n\n'
                    with open(bigpath+chem+'/'+file,'r') as f:
                        autosav += f.read()
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
        version[1]+=1
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    except:
        os.makedirs(bigpath+save_path)
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

    with open(bigpath+save_path+'saved_'+version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]+'.savd','w') as f:
        f.write(autosav)

    print('files saved, version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

def recup_files(path2):

    ##version obsolete de getback ?

    currentpath = path2.split('\\')[-1]
    currentpath = currentpath.split('/')[-1]
    currentpath = path2[:(len(path2)-len(currentpath))]

    all =[]
    with open(path2,'r') as f:
        all = f.readlines()

    files = {}
    titles = [0]
    file = []
    for line in all:
        if '_newfile_ :' in line and line[-4:] == '.py\n':
            name = line[len('_newfile_ '):]
            names = name.split('\\')
            names2 = []

            for nam in names:
                for naam in nam.split('/'):
                    names2.append(naam)
                    name = ('/').join(names2[-2:])

            files[titles[-1]] = file
            titles.append(name[:-1])
            file = []
        else:
            file.append(line)

    files[titles[-1]] = file

    for name in files:
        print(name)
        if name != 0:
            try:
                with open(currentpath+name,'w') as f:
                    for line in files[name]:
                        f.write(line)
            except :
                file = name.split('/')[0]
                os.makedirs(currentpath+file)
                with open(currentpath+name,'w') as f:
                    for line in files[name]:
                        f.write(line)

def get_version(bigpath,save_path = '/autosav/'):
    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
    except:
        a=0
    return version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]
"""
def compt(bigpath,path = ['/.','/src']):

    long = 0

    for chem in path:
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    with open(bigpath+chem+'/'+file,'r') as f:
                        long += len(f.readlines())
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    return long
